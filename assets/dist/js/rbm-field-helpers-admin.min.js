/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Main field class.
 *
 * @since 1.4.0
 */
var Field = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     * @param {string} type
     */
    function Field($field, type) {
        _classCallCheck(this, Field);

        this.$field = $field;
        this.$wrapper = $field.closest('.fieldhelpers-field');
        this.type = type;
        this.name = this.$wrapper.attr('data-fieldhelpers-name');
        this.instance = this.$wrapper.attr('data-fieldhelpers-instance');

        this.getRepeater();

        this.getOptions();

        if (this.repeater) {

            this.repeaterSupport();
        }

        // Put in global scope for other methods to interact with it
        if (typeof RBM_FieldHelpers[this.instance]['fieldObjects'] == 'undefined') {
            RBM_FieldHelpers[this.instance]['fieldObjects'] = {};
        }

        if (typeof RBM_FieldHelpers[this.instance]['fieldObjects'][this.type] == 'undefined') {
            RBM_FieldHelpers[this.instance]['fieldObjects'][this.type] = {};
        }

        RBM_FieldHelpers[this.instance]['fieldObjects'][this.type][this.name] = this;
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     */


    _createClass(Field, [{
        key: 'initField',
        value: function initField() {}

        /**
         * Gets field options.
         *
         * @since 1.4.0
         */

    }, {
        key: 'getOptions',
        value: function getOptions() {

            this.options = {};

            if (typeof RBM_FieldHelpers[this.instance] === 'undefined') {

                console.error('Field Helpers Error: Data for ' + this.instance + ' instance cannot be found.');
                return;
            }

            if (this.repeater) {

                if (typeof RBM_FieldHelpers[this.instance]['repeaterFields'][this.repeater] === 'undefined') {

                    console.error('Field Helpers Error: Data for repeater ' + this.type + ' sub-fields cannot be found.');
                    return;
                }

                if (typeof RBM_FieldHelpers[this.instance]['repeaterFields'][this.repeater][this.name] === 'undefined') {

                    console.error('Field Helpers Error: Cannot find field options for repeater ' + this.type + ' sub-field with name: ' + this.name + '.');
                    return;
                }

                this.options = RBM_FieldHelpers[this.instance]['repeaterFields'][this.repeater][this.name];
            } else {

                if (typeof RBM_FieldHelpers[this.instance][this.type] === 'undefined') {

                    console.error('Field Helpers Error: Data for ' + this.type + ' fields cannot be found.');
                    return;
                }

                if (typeof RBM_FieldHelpers[this.instance][this.type][this.name] === 'undefined') {

                    console.error('Field Helpers Error: Cannot find field options for ' + this.type + ' field with name: ' + this.name + '.');
                    return;
                }

                this.options = RBM_FieldHelpers[this.instance][this.type][this.name];
            }
        }

        /**
         * If field is in a Repeater, it will need support.
         *
         * @since 1.4.0
         */

    }, {
        key: 'getRepeater',
        value: function getRepeater() {

            if (this.$field.closest('[data-fieldhelpers-field-repeater]').length) {

                this.$repeater = this.$field.parent().closest('[data-fieldhelpers-field-repeater]');
                this.repeater = this.$repeater.closest('.fieldhelpers-field-repeater').attr('data-fieldhelpers-name');
            }
        }

        /**
         * Runs some functions if inside a Repeater.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterSupport',
        value: function repeaterSupport() {
            var _this = this;

            // Triggers fields can utilize. Wrapped in anonymous to utilize self access.
            this.$repeater.on('repeater-init', function () {
                _this.repeaterOnInit();
            });
            this.$repeater.on('repeater-before-add-item', function () {
                _this.repeaterBeforeAddItem();
            });
            this.$repeater.on('repeater-add-item', function () {
                _this.repeaterOnAddItem();
            });
            this.$field.closest('[data-repeater-item]').on('repeater-before-delete-item', function () {
                _this.repeaterBeforeDeleteSelf();
            });
            this.$repeater.on('repeater-before-delete-item', function () {
                _this.repeaterBeforeDeleteItem();
            });
            this.$repeater.on('repeater-delete-item', function () {
                _this.repeaterOnDeleteItem();
            });
            this.$repeater.find('.fieldhelpers-field-repeater-list').on('list-update', function () {
                _this.repeaterOnSort();
            });

            this.repeaterSetID();
            this.fieldCleanup();
        }

        /**
         * Fires on Repeater init.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterOnInit',
        value: function repeaterOnInit() {}

        /**
         * Fires before Repeater add item.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterBeforeAddItem',
        value: function repeaterBeforeAddItem() {}

        /**
         * Fires on Repeater add item.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterOnAddItem',
        value: function repeaterOnAddItem() {}

        /**
         * Fires before Repeater delete item (localized to self).
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterBeforeDeleteSelf',
        value: function repeaterBeforeDeleteSelf() {}

        /**
         * Fires before Repeater delete item.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterBeforeDeleteItem',
        value: function repeaterBeforeDeleteItem() {}

        /**
         * Fires on Repeater delete item.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterOnDeleteItem',
        value: function repeaterOnDeleteItem() {}

        /**
         * Fires on Repeat sort item.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterOnSort',
        value: function repeaterOnSort() {}

        /**
         * Sets the ID to be unique, based off the repeater item index.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterSetID',
        value: function repeaterSetID() {

            var index = this.$field.closest('[data-repeater-item]').index();
            var newID = this.options.id + '_' + index;

            this.$field.attr('id', newID);
        }

        /**
         * Cleans up after a repeater add/init.
         *
         * @since 1.4.0
         */

    }, {
        key: 'fieldCleanup',
        value: function fieldCleanup() {}

        /**
         * Sets the field to default. Override in child class if need different method.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setDefault',
        value: function setDefault() {

            if (this.options.default) {

                this.$field.val(this.options.default).change();
            }
        }
    }]);

    return Field;
}();

exports.default = Field;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _fieldNumber = __webpack_require__(8);

var _fieldNumber2 = _interopRequireDefault(_fieldNumber);

var _fieldColorpicker = __webpack_require__(9);

var _fieldColorpicker2 = _interopRequireDefault(_fieldColorpicker);

var _fieldDatepicker = __webpack_require__(10);

var _fieldDatepicker2 = _interopRequireDefault(_fieldDatepicker);

var _fieldTimepicker = __webpack_require__(11);

var _fieldTimepicker2 = _interopRequireDefault(_fieldTimepicker);

var _fieldDatetimepicker = __webpack_require__(12);

var _fieldDatetimepicker2 = _interopRequireDefault(_fieldDatetimepicker);

var _fieldTable = __webpack_require__(13);

var _fieldTable2 = _interopRequireDefault(_fieldTable);

var _fieldMedia = __webpack_require__(14);

var _fieldMedia2 = _interopRequireDefault(_fieldMedia);

var _fieldList = __webpack_require__(15);

var _fieldList2 = _interopRequireDefault(_fieldList);

var _fieldRepeater = __webpack_require__(16);

var _fieldRepeater2 = _interopRequireDefault(_fieldRepeater);

var _fieldSelect = __webpack_require__(17);

var _fieldSelect2 = _interopRequireDefault(_fieldSelect);

var _fieldTextarea = __webpack_require__(18);

var _fieldTextarea2 = _interopRequireDefault(_fieldTextarea);

var _fieldCheckbox = __webpack_require__(19);

var _fieldCheckbox2 = _interopRequireDefault(_fieldCheckbox);

var _fieldRadio = __webpack_require__(20);

var _fieldRadio2 = _interopRequireDefault(_fieldRadio);

var _fieldToggle = __webpack_require__(21);

var _fieldToggle2 = _interopRequireDefault(_fieldToggle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Handles all field initializations.
 *
 * @since 1.4.0
 */
var FieldsInitialize =

/**
 * Class constructor.
 *
 * @since 1.4.0
 *
 * @param {jQuery} $root Root element to initialize fields inside.
 */
function FieldsInitialize($root) {
    _classCallCheck(this, FieldsInitialize);

    this.fields = {
        checkbox: new _fieldCheckbox2.default($root),
        toggle: new _fieldToggle2.default($root),
        radio: new _fieldRadio2.default($root),
        select: new _fieldSelect2.default($root),
        textarea: new _fieldTextarea2.default($root),
        number: new _fieldNumber2.default($root),
        colorpicker: new _fieldColorpicker2.default($root),
        datepicker: new _fieldDatepicker2.default($root),
        timepicker: new _fieldTimepicker2.default($root),
        datetimepicker: new _fieldDatetimepicker2.default($root),
        table: new _fieldTable2.default($root),
        media: new _fieldMedia2.default($root),
        list: new _fieldList2.default($root),
        repeater: new _fieldRepeater2.default($root)
    };
};

exports.default = FieldsInitialize;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(3);


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(4);

__webpack_require__(5);

var _fieldsInit = __webpack_require__(1);

var _fieldsInit2 = _interopRequireDefault(_fieldsInit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Initialize app on jQuery Ready.
jQuery(function () {

	var Fields = new _fieldsInit2.default(jQuery(document));
});

// Re-init any fields within a container
window.rbmFHinitField = function ($root) {

	new _fieldsInit2.default($root);
};

// Grab Field Object from the RBM_FieldHelpers global in order to run methods on them
window.rbmFHgetFieldObject = function (name) {
	var instance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	var fieldType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


	if (instance === null) {

		instance = jQuery('.fieldhelpers-field[data-fieldhelpers-name="' + name + '"]').data('fieldhelpers-instance');
	}

	if (fieldType === null) {

		var classNames = jQuery('.fieldhelpers-field[data-fieldhelpers-name="' + name + '"][data-fieldhelpers-instance="' + instance + '"]').first().attr('class');

		var test = /fieldhelpers-field-(\S*)/.exec(classNames);

		if (test !== null && test[1].length > 0) {

			fieldType = test[1];
		}
	}

	try {

		return RBM_FieldHelpers[instance]['fieldObjects'][fieldType][name];
	} catch (error) {

		if (instance === null || fieldType === null || RBM_FieldHelpers[instance]['fieldObjects'][fieldType][name].length < 0) {
			console.error('Field Helpers Error: Field Object for "' + name + '" Not Found');
		}

		return false;
	}
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// jquery.repeater version 1.2.1
// https://github.com/DubFriend/jquery.repeater
// (MIT) 09-10-2016
// Brian Detering <BDeterin@gmail.com> (http://www.briandetering.net/)
(function ($) {
    'use strict';

    var identity = function identity(x) {
        return x;
    };

    var isArray = function isArray(value) {
        return $.isArray(value);
    };

    var isObject = function isObject(value) {
        return !isArray(value) && value instanceof Object;
    };

    var isNumber = function isNumber(value) {
        return value instanceof Number;
    };

    var isFunction = function isFunction(value) {
        return value instanceof Function;
    };

    var indexOf = function indexOf(object, value) {
        return $.inArray(value, object);
    };

    var inArray = function inArray(array, value) {
        return indexOf(array, value) !== -1;
    };

    var foreach = function foreach(collection, callback) {
        for (var i in collection) {
            if (collection.hasOwnProperty(i)) {
                callback(collection[i], i, collection);
            }
        }
    };

    var last = function last(array) {
        return array[array.length - 1];
    };

    var argumentsToArray = function argumentsToArray(args) {
        return Array.prototype.slice.call(args);
    };

    var extend = function extend() {
        var extended = {};
        foreach(argumentsToArray(arguments), function (o) {
            foreach(o, function (val, key) {
                extended[key] = val;
            });
        });
        return extended;
    };

    var mapToArray = function mapToArray(collection, callback) {
        var mapped = [];
        foreach(collection, function (value, key, coll) {
            mapped.push(callback(value, key, coll));
        });
        return mapped;
    };

    var mapToObject = function mapToObject(collection, callback, keyCallback) {
        var mapped = {};
        foreach(collection, function (value, key, coll) {
            key = keyCallback ? keyCallback(key, value) : key;
            mapped[key] = callback(value, key, coll);
        });
        return mapped;
    };

    var map = function map(collection, callback, keyCallback) {
        return isArray(collection) ? mapToArray(collection, callback) : mapToObject(collection, callback, keyCallback);
    };

    var pluck = function pluck(arrayOfObjects, key) {
        return map(arrayOfObjects, function (val) {
            return val[key];
        });
    };

    var filter = function filter(collection, callback) {
        var filtered;

        if (isArray(collection)) {
            filtered = [];
            foreach(collection, function (val, key, coll) {
                if (callback(val, key, coll)) {
                    filtered.push(val);
                }
            });
        } else {
            filtered = {};
            foreach(collection, function (val, key, coll) {
                if (callback(val, key, coll)) {
                    filtered[key] = val;
                }
            });
        }

        return filtered;
    };

    var call = function call(collection, functionName, args) {
        return map(collection, function (object, name) {
            return object[functionName].apply(object, args || []);
        });
    };

    //execute callback immediately and at most one time on the minimumInterval,
    //ignore block attempts
    var throttle = function throttle(minimumInterval, callback) {
        var timeout = null;
        return function () {
            var that = this,
                args = arguments;
            if (timeout === null) {
                timeout = setTimeout(function () {
                    timeout = null;
                }, minimumInterval);
                callback.apply(that, args);
            }
        };
    };

    var mixinPubSub = function mixinPubSub(object) {
        object = object || {};
        var topics = {};

        object.publish = function (topic, data) {
            foreach(topics[topic], function (callback) {
                callback(data);
            });
        };

        object.subscribe = function (topic, callback) {
            topics[topic] = topics[topic] || [];
            topics[topic].push(callback);
        };

        object.unsubscribe = function (callback) {
            foreach(topics, function (subscribers) {
                var index = indexOf(subscribers, callback);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
            });
        };

        return object;
    };

    // jquery.input version 0.0.0
    // https://github.com/DubFriend/jquery.input
    // (MIT) 09-04-2014
    // Brian Detering <BDeterin@gmail.com> (http://www.briandetering.net/)
    (function ($) {
        'use strict';

        var createBaseInput = function createBaseInput(fig, my) {
            var self = mixinPubSub(),
                $self = fig.$;

            self.getType = function () {
                throw 'implement me (return type. "text", "radio", etc.)';
            };

            self.$ = function (selector) {
                return selector ? $self.find(selector) : $self;
            };

            self.disable = function () {
                self.$().prop('disabled', true);
                self.publish('isEnabled', false);
            };

            self.enable = function () {
                self.$().prop('disabled', false);
                self.publish('isEnabled', true);
            };

            my.equalTo = function (a, b) {
                return a === b;
            };

            my.publishChange = function () {
                var oldValue;
                return function (e, domElement) {
                    var newValue = self.get();
                    if (!my.equalTo(newValue, oldValue)) {
                        self.publish('change', { e: e, domElement: domElement });
                    }
                    oldValue = newValue;
                };
            }();

            return self;
        };

        var createInput = function createInput(fig, my) {
            var self = createBaseInput(fig, my);

            self.get = function () {
                return self.$().val();
            };

            self.set = function (newValue) {
                self.$().val(newValue);
            };

            self.clear = function () {
                self.set('');
            };

            my.buildSetter = function (callback) {
                return function (newValue) {
                    callback.call(self, newValue);
                };
            };

            return self;
        };

        var inputEqualToArray = function inputEqualToArray(a, b) {
            a = isArray(a) ? a : [a];
            b = isArray(b) ? b : [b];

            var isEqual = true;
            if (a.length !== b.length) {
                isEqual = false;
            } else {
                foreach(a, function (value) {
                    if (!inArray(b, value)) {
                        isEqual = false;
                    }
                });
            }

            return isEqual;
        };

        var createInputButton = function createInputButton(fig) {
            var my = {},
                self = createInput(fig, my);

            self.getType = function () {
                return 'button';
            };

            self.$().on('change', function (e) {
                my.publishChange(e, this);
            });

            return self;
        };

        var createInputCheckbox = function createInputCheckbox(fig) {
            var my = {},
                self = createInput(fig, my);

            self.getType = function () {
                return 'checkbox';
            };

            self.get = function () {
                var values = [];
                self.$().filter(':checked').each(function () {
                    values.push($(this).val());
                });
                return values;
            };

            self.set = function (newValues) {
                newValues = isArray(newValues) ? newValues : [newValues];

                self.$().each(function () {
                    $(this).prop('checked', false);
                });

                foreach(newValues, function (value) {
                    self.$().filter('[value="' + value + '"]').prop('checked', true);
                });
            };

            my.equalTo = inputEqualToArray;

            self.$().change(function (e) {
                my.publishChange(e, this);
            });

            return self;
        };

        var createInputEmail = function createInputEmail(fig) {
            var my = {},
                self = createInputText(fig, my);

            self.getType = function () {
                return 'email';
            };

            return self;
        };

        var createInputFile = function createInputFile(fig) {
            var my = {},
                self = createBaseInput(fig, my);

            self.getType = function () {
                return 'file';
            };

            self.get = function () {
                return last(self.$().val().split('\\'));
            };

            self.clear = function () {
                // http://stackoverflow.com/questions/1043957/clearing-input-type-file-using-jquery
                this.$().each(function () {
                    $(this).wrap('<form>').closest('form').get(0).reset();
                    $(this).unwrap();
                });
            };

            self.$().change(function (e) {
                my.publishChange(e, this);
                // self.publish('change', self);
            });

            return self;
        };

        var createInputHidden = function createInputHidden(fig) {
            var my = {},
                self = createInput(fig, my);

            self.getType = function () {
                return 'hidden';
            };

            self.$().change(function (e) {
                my.publishChange(e, this);
            });

            return self;
        };
        var createInputMultipleFile = function createInputMultipleFile(fig) {
            var my = {},
                self = createBaseInput(fig, my);

            self.getType = function () {
                return 'file[multiple]';
            };

            self.get = function () {
                // http://stackoverflow.com/questions/14035530/how-to-get-value-of-html-5-multiple-file-upload-variable-using-jquery
                var fileListObject = self.$().get(0).files || [],
                    names = [],
                    i;

                for (i = 0; i < (fileListObject.length || 0); i += 1) {
                    names.push(fileListObject[i].name);
                }

                return names;
            };

            self.clear = function () {
                // http://stackoverflow.com/questions/1043957/clearing-input-type-file-using-jquery
                this.$().each(function () {
                    $(this).wrap('<form>').closest('form').get(0).reset();
                    $(this).unwrap();
                });
            };

            self.$().change(function (e) {
                my.publishChange(e, this);
            });

            return self;
        };

        var createInputMultipleSelect = function createInputMultipleSelect(fig) {
            var my = {},
                self = createInput(fig, my);

            self.getType = function () {
                return 'select[multiple]';
            };

            self.get = function () {
                return self.$().val() || [];
            };

            self.set = function (newValues) {
                self.$().val(newValues === '' ? [] : isArray(newValues) ? newValues : [newValues]);
            };

            my.equalTo = inputEqualToArray;

            self.$().change(function (e) {
                my.publishChange(e, this);
            });

            return self;
        };

        var createInputPassword = function createInputPassword(fig) {
            var my = {},
                self = createInputText(fig, my);

            self.getType = function () {
                return 'password';
            };

            return self;
        };

        var createInputRadio = function createInputRadio(fig) {
            var my = {},
                self = createInput(fig, my);

            self.getType = function () {
                return 'radio';
            };

            self.get = function () {
                return self.$().filter(':checked').val() || null;
            };

            self.set = function (newValue) {
                if (!newValue) {
                    self.$().each(function () {
                        $(this).prop('checked', false);
                    });
                } else {
                    self.$().filter('[value="' + newValue + '"]').prop('checked', true);
                }
            };

            self.$().change(function (e) {
                my.publishChange(e, this);
            });

            return self;
        };

        var createInputRange = function createInputRange(fig) {
            var my = {},
                self = createInput(fig, my);

            self.getType = function () {
                return 'range';
            };

            self.$().change(function (e) {
                my.publishChange(e, this);
            });

            return self;
        };

        var createInputSelect = function createInputSelect(fig) {
            var my = {},
                self = createInput(fig, my);

            self.getType = function () {
                return 'select';
            };

            self.$().change(function (e) {
                my.publishChange(e, this);
            });

            return self;
        };

        var createInputText = function createInputText(fig) {
            var my = {},
                self = createInput(fig, my);

            self.getType = function () {
                return 'text';
            };

            self.$().on('change keyup keydown', function (e) {
                my.publishChange(e, this);
            });

            return self;
        };

        var createInputTextarea = function createInputTextarea(fig) {
            var my = {},
                self = createInput(fig, my);

            self.getType = function () {
                return 'textarea';
            };

            self.$().on('change keyup keydown', function (e) {
                my.publishChange(e, this);
            });

            return self;
        };

        var createInputURL = function createInputURL(fig) {
            var my = {},
                self = createInputText(fig, my);

            self.getType = function () {
                return 'url';
            };

            return self;
        };

        var buildFormInputs = function buildFormInputs(fig) {
            var inputs = {},
                $self = fig.$;

            var constructor = fig.constructorOverride || {
                button: createInputButton,
                text: createInputText,
                url: createInputURL,
                email: createInputEmail,
                password: createInputPassword,
                range: createInputRange,
                textarea: createInputTextarea,
                select: createInputSelect,
                'select[multiple]': createInputMultipleSelect,
                radio: createInputRadio,
                checkbox: createInputCheckbox,
                file: createInputFile,
                'file[multiple]': createInputMultipleFile,
                hidden: createInputHidden
            };

            var addInputsBasic = function addInputsBasic(type, selector) {
                var $input = isObject(selector) ? selector : $self.find(selector);

                $input.each(function () {
                    var name = $(this).attr('name');
                    inputs[name] = constructor[type]({
                        $: $(this)
                    });
                });
            };

            var addInputsGroup = function addInputsGroup(type, selector) {
                var names = [],
                    $input = isObject(selector) ? selector : $self.find(selector);

                if (isObject(selector)) {
                    inputs[$input.attr('name')] = constructor[type]({
                        $: $input
                    });
                } else {
                    // group by name attribute
                    $input.each(function () {
                        if (indexOf(names, $(this).attr('name')) === -1) {
                            names.push($(this).attr('name'));
                        }
                    });

                    foreach(names, function (name) {
                        inputs[name] = constructor[type]({
                            $: $self.find('input[name="' + name + '"]')
                        });
                    });
                }
            };

            if ($self.is('input, select, textarea')) {
                if ($self.is('input[type="button"], button, input[type="submit"]')) {
                    addInputsBasic('button', $self);
                } else if ($self.is('textarea')) {
                    addInputsBasic('textarea', $self);
                } else if ($self.is('input[type="text"]') || $self.is('input') && !$self.attr('type')) {
                    addInputsBasic('text', $self);
                } else if ($self.is('input[type="password"]')) {
                    addInputsBasic('password', $self);
                } else if ($self.is('input[type="email"]')) {
                    addInputsBasic('email', $self);
                } else if ($self.is('input[type="url"]')) {
                    addInputsBasic('url', $self);
                } else if ($self.is('input[type="range"]')) {
                    addInputsBasic('range', $self);
                } else if ($self.is('select')) {
                    if ($self.is('[multiple]')) {
                        addInputsBasic('select[multiple]', $self);
                    } else {
                        addInputsBasic('select', $self);
                    }
                } else if ($self.is('input[type="file"]')) {
                    if ($self.is('[multiple]')) {
                        addInputsBasic('file[multiple]', $self);
                    } else {
                        addInputsBasic('file', $self);
                    }
                } else if ($self.is('input[type="hidden"]')) {
                    addInputsBasic('hidden', $self);
                } else if ($self.is('input[type="radio"]')) {
                    addInputsGroup('radio', $self);
                } else if ($self.is('input[type="checkbox"]')) {
                    addInputsGroup('checkbox', $self);
                } else {
                    //in all other cases default to a "text" input interface.
                    addInputsBasic('text', $self);
                }
            } else {
                addInputsBasic('button', 'input[type="button"], button, input[type="submit"]');
                addInputsBasic('text', 'input[type="text"]');
                addInputsBasic('password', 'input[type="password"]');
                addInputsBasic('email', 'input[type="email"]');
                addInputsBasic('url', 'input[type="url"]');
                addInputsBasic('range', 'input[type="range"]');
                addInputsBasic('textarea', 'textarea');
                addInputsBasic('select', 'select:not([multiple])');
                addInputsBasic('select[multiple]', 'select[multiple]');
                addInputsBasic('file', 'input[type="file"]:not([multiple])');
                addInputsBasic('file[multiple]', 'input[type="file"][multiple]');
                addInputsBasic('hidden', 'input[type="hidden"]');
                addInputsGroup('radio', 'input[type="radio"]');
                addInputsGroup('checkbox', 'input[type="checkbox"]');
            }

            return inputs;
        };

        $.fn.inputVal = function (newValue) {
            var $self = $(this);

            var inputs = buildFormInputs({ $: $self });

            if ($self.is('input, textarea, select')) {
                if (typeof newValue === 'undefined') {
                    return inputs[$self.attr('name')].get();
                } else {
                    inputs[$self.attr('name')].set(newValue);
                    return $self;
                }
            } else {
                if (typeof newValue === 'undefined') {
                    return call(inputs, 'get');
                } else {
                    foreach(newValue, function (value, inputName) {
                        inputs[inputName].set(value);
                    });
                    return $self;
                }
            }
        };

        $.fn.inputOnChange = function (callback) {
            var $self = $(this);
            var inputs = buildFormInputs({ $: $self });
            foreach(inputs, function (input) {
                input.subscribe('change', function (data) {
                    callback.call(data.domElement, data.e);
                });
            });
            return $self;
        };

        $.fn.inputDisable = function () {
            var $self = $(this);
            call(buildFormInputs({ $: $self }), 'disable');
            return $self;
        };

        $.fn.inputEnable = function () {
            var $self = $(this);
            call(buildFormInputs({ $: $self }), 'enable');
            return $self;
        };

        $.fn.inputClear = function () {
            var $self = $(this);
            call(buildFormInputs({ $: $self }), 'clear');
            return $self;
        };
    })(jQuery);

    $.fn.repeaterVal = function () {
        var parse = function parse(raw) {
            var parsed = [];

            foreach(raw, function (val, key) {
                var parsedKey = [];
                if (key !== "undefined") {
                    parsedKey.push(key.match(/^[^\[]*/)[0]);
                    parsedKey = parsedKey.concat(map(key.match(/\[[^\]]*\]/g), function (bracketed) {
                        return bracketed.replace(/[\[\]]/g, '');
                    }));

                    parsed.push({
                        val: val,
                        key: parsedKey
                    });
                }
            });

            return parsed;
        };

        var build = function build(parsed) {
            if (parsed.length === 1 && (parsed[0].key.length === 0 || parsed[0].key.length === 1 && !parsed[0].key[0])) {
                return parsed[0].val;
            }

            foreach(parsed, function (p) {
                p.head = p.key.shift();
            });

            var grouped = function () {
                var grouped = {};

                foreach(parsed, function (p) {
                    if (!grouped[p.head]) {
                        grouped[p.head] = [];
                    }
                    grouped[p.head].push(p);
                });

                return grouped;
            }();

            var built;

            if (/^[0-9]+$/.test(parsed[0].head)) {
                built = [];
                foreach(grouped, function (group) {
                    built.push(build(group));
                });
            } else {
                built = {};
                foreach(grouped, function (group, key) {
                    built[key] = build(group);
                });
            }

            return built;
        };

        return build(parse($(this).inputVal()));
    };

    $.fn.repeater = function (fig) {
        fig = fig || {};

        var setList;

        $(this).each(function () {

            var $self = $(this);

            var show = fig.show || function () {
                $(this).show();
            };

            var hide = fig.hide || function (removeElement) {
                removeElement();
            };

            var $list = $self.find('[data-repeater-list]').first();

            var $filterNested = function $filterNested($items, repeaters) {
                return $items.filter(function () {
                    return repeaters ? $(this).closest(pluck(repeaters, 'selector').join(',')).length === 0 : true;
                });
            };

            var $items = function $items() {
                return $filterNested($list.find('[data-repeater-item]'), fig.repeaters);
            };

            var $itemTemplate = $list.find('[data-repeater-item]').first().clone().hide();

            var $firstDeleteButton = $filterNested($filterNested($(this).find('[data-repeater-item]'), fig.repeaters).first().find('[data-repeater-delete]'), fig.repeaters);

            if (fig.isFirstItemUndeletable && $firstDeleteButton) {
                $firstDeleteButton.remove();
            }

            var getGroupName = function getGroupName() {
                var groupName = $list.data('repeater-list');
                return fig.$parent ? fig.$parent.data('item-name') + '[' + groupName + ']' : groupName;
            };

            var initNested = function initNested($listItems) {
                if (fig.repeaters) {
                    $listItems.each(function () {
                        var $item = $(this);
                        foreach(fig.repeaters, function (nestedFig) {
                            $item.find(nestedFig.selector).repeater(extend(nestedFig, { $parent: $item }));
                        });
                    });
                }
            };

            var $foreachRepeaterInItem = function $foreachRepeaterInItem(repeaters, $item, cb) {
                if (repeaters) {
                    foreach(repeaters, function (nestedFig) {
                        cb.call($item.find(nestedFig.selector)[0], nestedFig);
                    });
                }
            };

            var setIndexes = function setIndexes($items, groupName, repeaters) {
                $items.each(function (index) {
                    var $item = $(this);
                    $item.data('item-name', groupName + '[' + index + ']');
                    $filterNested($item.find('[name]'), repeaters).each(function () {
                        var $input = $(this);
                        // match non empty brackets (ex: "[foo]")
                        var matches = $input.attr('name').match(/\[[^\]]+\]/g);

                        var name = matches ?
                        // strip "[" and "]" characters
                        last(matches).replace(/\[|\]/g, '') : $input.attr('name');

                        var newName = groupName + '[' + index + '][' + name + ']' + ($input.is(':checkbox') || $input.attr('multiple') ? '[]' : '');

                        $input.attr('name', newName);

                        $foreachRepeaterInItem(repeaters, $item, function (nestedFig) {
                            var $repeater = $(this);
                            setIndexes($filterNested($repeater.find('[data-repeater-item]'), nestedFig.repeaters || []), groupName + '[' + index + ']' + '[' + $repeater.find('[data-repeater-list]').first().data('repeater-list') + ']', nestedFig.repeaters);
                        });
                    });
                });

                $list.find('input[name][checked]').removeAttr('checked').prop('checked', true);
            };

            setIndexes($items(), getGroupName(), fig.repeaters);
            initNested($items());
            if (fig.initEmpty) {
                $items().remove();
            }

            if (fig.ready) {
                fig.ready(function () {
                    setIndexes($items(), getGroupName(), fig.repeaters);
                });
            }

            var appendItem = function () {
                var setItemsValues = function setItemsValues($item, data, repeaters) {
                    if (data || fig.defaultValues) {
                        var inputNames = {};
                        $filterNested($item.find('[name]'), repeaters).each(function () {
                            var key = $(this).attr('name').match(/\[([^\]]*)(\]|\]\[\])$/)[1];
                            inputNames[key] = $(this).attr('name');
                        });

                        $item.inputVal(map(filter(data || fig.defaultValues, function (val, name) {
                            return inputNames[name];
                        }), identity, function (name) {
                            return inputNames[name];
                        }));
                    }

                    $foreachRepeaterInItem(repeaters, $item, function (nestedFig) {
                        var $repeater = $(this);
                        $filterNested($repeater.find('[data-repeater-item]'), nestedFig.repeaters).each(function () {
                            var fieldName = $repeater.find('[data-repeater-list]').data('repeater-list');
                            if (data && data[fieldName]) {
                                var $template = $(this).clone();
                                $repeater.find('[data-repeater-item]').remove();
                                foreach(data[fieldName], function (data) {
                                    var $item = $template.clone();
                                    setItemsValues($item, data, nestedFig.repeaters || []);
                                    $repeater.find('[data-repeater-list]').append($item);
                                });
                            } else {
                                setItemsValues($(this), nestedFig.defaultValues, nestedFig.repeaters || []);
                            }
                        });
                    });
                };

                return function ($item, data) {
                    $list.append($item);
                    setIndexes($items(), getGroupName(), fig.repeaters);
                    $item.find('[name]').each(function () {
                        $(this).inputClear();
                    });
                    setItemsValues($item, data || fig.defaultValues, fig.repeaters);
                };
            }();

            var addItem = function addItem(data) {
                var $item = $itemTemplate.clone();
                appendItem($item, data);
                if (fig.repeaters) {
                    initNested($item);
                }
                show.call($item.get(0));
            };

            setList = function setList(rows) {
                $items().remove();
                foreach(rows, addItem);
            };

            $filterNested($self.find('[data-repeater-create]'), fig.repeaters).click(function () {
                addItem();
            });

            $list.on('click', '[data-repeater-delete]', function () {
                var self = $(this).closest('[data-repeater-item]').get(0);
                hide.call(self, function () {
                    $(self).remove();
                    setIndexes($items(), getGroupName(), fig.repeaters);
                });
            });
        });

        this.setList = setList;

        return this;
    };
})(jQuery);

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! jQuery Timepicker Addon - v1.6.3 - 2016-04-20
* http://trentrichardson.com/examples/timepicker
* Copyright (c) 2016 Trent Richardson; Licensed MIT */
(function (factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		factory(jQuery);
	}
})(function ($) {

	/*
 * Lets not redefine timepicker, Prevent "Uncaught RangeError: Maximum call stack size exceeded"
 */
	$.ui.timepicker = $.ui.timepicker || {};
	if ($.ui.timepicker.version) {
		return;
	}

	/*
 * Extend jQueryUI, get it started with our version number
 */
	$.extend($.ui, {
		timepicker: {
			version: "1.6.3"
		}
	});

	/*
 * Timepicker manager.
 * Use the singleton instance of this class, $.timepicker, to interact with the time picker.
 * Settings for (groups of) time pickers are maintained in an instance object,
 * allowing multiple different settings on the same page.
 */
	var Timepicker = function Timepicker() {
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[''] = { // Default regional settings
			currentText: 'Now',
			closeText: 'Done',
			amNames: ['AM', 'A'],
			pmNames: ['PM', 'P'],
			timeFormat: 'HH:mm',
			timeSuffix: '',
			timeOnlyTitle: 'Choose Time',
			timeText: 'Time',
			hourText: 'Hour',
			minuteText: 'Minute',
			secondText: 'Second',
			millisecText: 'Millisecond',
			microsecText: 'Microsecond',
			timezoneText: 'Time Zone',
			isRTL: false
		};
		this._defaults = { // Global defaults for all the datetime picker instances
			showButtonPanel: true,
			timeOnly: false,
			timeOnlyShowDate: false,
			showHour: null,
			showMinute: null,
			showSecond: null,
			showMillisec: null,
			showMicrosec: null,
			showTimezone: null,
			showTime: true,
			stepHour: 1,
			stepMinute: 1,
			stepSecond: 1,
			stepMillisec: 1,
			stepMicrosec: 1,
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null,
			hourMin: 0,
			minuteMin: 0,
			secondMin: 0,
			millisecMin: 0,
			microsecMin: 0,
			hourMax: 23,
			minuteMax: 59,
			secondMax: 59,
			millisecMax: 999,
			microsecMax: 999,
			minDateTime: null,
			maxDateTime: null,
			maxTime: null,
			minTime: null,
			onSelect: null,
			hourGrid: 0,
			minuteGrid: 0,
			secondGrid: 0,
			millisecGrid: 0,
			microsecGrid: 0,
			alwaysSetTime: true,
			separator: ' ',
			altFieldTimeOnly: true,
			altTimeFormat: null,
			altSeparator: null,
			altTimeSuffix: null,
			altRedirectFocus: true,
			pickerTimeFormat: null,
			pickerTimeSuffix: null,
			showTimepicker: true,
			timezoneList: null,
			addSliderAccess: false,
			sliderAccessArgs: null,
			controlType: 'slider',
			oneLine: false,
			defaultValue: null,
			parse: 'strict',
			afterInject: null
		};
		$.extend(this._defaults, this.regional['']);
	};

	$.extend(Timepicker.prototype, {
		$input: null,
		$altInput: null,
		$timeObj: null,
		inst: null,
		hour_slider: null,
		minute_slider: null,
		second_slider: null,
		millisec_slider: null,
		microsec_slider: null,
		timezone_select: null,
		maxTime: null,
		minTime: null,
		hour: 0,
		minute: 0,
		second: 0,
		millisec: 0,
		microsec: 0,
		timezone: null,
		hourMinOriginal: null,
		minuteMinOriginal: null,
		secondMinOriginal: null,
		millisecMinOriginal: null,
		microsecMinOriginal: null,
		hourMaxOriginal: null,
		minuteMaxOriginal: null,
		secondMaxOriginal: null,
		millisecMaxOriginal: null,
		microsecMaxOriginal: null,
		ampm: '',
		formattedDate: '',
		formattedTime: '',
		formattedDateTime: '',
		timezoneList: null,
		units: ['hour', 'minute', 'second', 'millisec', 'microsec'],
		support: {},
		control: null,

		/*
  * Override the default settings for all instances of the time picker.
  * @param  {Object} settings  object - the new settings to use as defaults (anonymous object)
  * @return {Object} the manager object
  */
		setDefaults: function setDefaults(settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},

		/*
  * Create a new Timepicker instance
  */
		_newInst: function _newInst($input, opts) {
			var tp_inst = new Timepicker(),
			    inlineSettings = {},
			    fns = {},
			    overrides,
			    i;

			for (var attrName in this._defaults) {
				if (this._defaults.hasOwnProperty(attrName)) {
					var attrValue = $input.attr('time:' + attrName);
					if (attrValue) {
						try {
							inlineSettings[attrName] = eval(attrValue);
						} catch (err) {
							inlineSettings[attrName] = attrValue;
						}
					}
				}
			}

			overrides = {
				beforeShow: function beforeShow(input, dp_inst) {
					if ($.isFunction(tp_inst._defaults.evnts.beforeShow)) {
						return tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst);
					}
				},
				onChangeMonthYear: function onChangeMonthYear(year, month, dp_inst) {
					// Update the time as well : this prevents the time from disappearing from the $input field.
					// tp_inst._updateDateTime(dp_inst);
					if ($.isFunction(tp_inst._defaults.evnts.onChangeMonthYear)) {
						tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
					}
				},
				onClose: function onClose(dateText, dp_inst) {
					if (tp_inst.timeDefined === true && $input.val() !== '') {
						tp_inst._updateDateTime(dp_inst);
					}
					if ($.isFunction(tp_inst._defaults.evnts.onClose)) {
						tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
					}
				}
			};
			for (i in overrides) {
				if (overrides.hasOwnProperty(i)) {
					fns[i] = opts[i] || this._defaults[i] || null;
				}
			}

			tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, opts, overrides, {
				evnts: fns,
				timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
			});
			tp_inst.amNames = $.map(tp_inst._defaults.amNames, function (val) {
				return val.toUpperCase();
			});
			tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function (val) {
				return val.toUpperCase();
			});

			// detect which units are supported
			tp_inst.support = detectSupport(tp_inst._defaults.timeFormat + (tp_inst._defaults.pickerTimeFormat ? tp_inst._defaults.pickerTimeFormat : '') + (tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : ''));

			// controlType is string - key to our this._controls
			if (typeof tp_inst._defaults.controlType === 'string') {
				if (tp_inst._defaults.controlType === 'slider' && typeof $.ui.slider === 'undefined') {
					tp_inst._defaults.controlType = 'select';
				}
				tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType];
			}
			// controlType is an object and must implement create, options, value methods
			else {
					tp_inst.control = tp_inst._defaults.controlType;
				}

			// prep the timezone options
			var timezoneList = [-720, -660, -600, -570, -540, -480, -420, -360, -300, -270, -240, -210, -180, -120, -60, 0, 60, 120, 180, 210, 240, 270, 300, 330, 345, 360, 390, 420, 480, 525, 540, 570, 600, 630, 660, 690, 720, 765, 780, 840];
			if (tp_inst._defaults.timezoneList !== null) {
				timezoneList = tp_inst._defaults.timezoneList;
			}
			var tzl = timezoneList.length,
			    tzi = 0,
			    tzv = null;
			if (tzl > 0 && _typeof(timezoneList[0]) !== 'object') {
				for (; tzi < tzl; tzi++) {
					tzv = timezoneList[tzi];
					timezoneList[tzi] = { value: tzv, label: $.timepicker.timezoneOffsetString(tzv, tp_inst.support.iso8601) };
				}
			}
			tp_inst._defaults.timezoneList = timezoneList;

			// set the default units
			tp_inst.timezone = tp_inst._defaults.timezone !== null ? $.timepicker.timezoneOffsetNumber(tp_inst._defaults.timezone) : new Date().getTimezoneOffset() * -1;
			tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin ? tp_inst._defaults.hourMin : tp_inst._defaults.hour > tp_inst._defaults.hourMax ? tp_inst._defaults.hourMax : tp_inst._defaults.hour;
			tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin ? tp_inst._defaults.minuteMin : tp_inst._defaults.minute > tp_inst._defaults.minuteMax ? tp_inst._defaults.minuteMax : tp_inst._defaults.minute;
			tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin ? tp_inst._defaults.secondMin : tp_inst._defaults.second > tp_inst._defaults.secondMax ? tp_inst._defaults.secondMax : tp_inst._defaults.second;
			tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin ? tp_inst._defaults.millisecMin : tp_inst._defaults.millisec > tp_inst._defaults.millisecMax ? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec;
			tp_inst.microsec = tp_inst._defaults.microsec < tp_inst._defaults.microsecMin ? tp_inst._defaults.microsecMin : tp_inst._defaults.microsec > tp_inst._defaults.microsecMax ? tp_inst._defaults.microsecMax : tp_inst._defaults.microsec;
			tp_inst.ampm = '';
			tp_inst.$input = $input;

			if (tp_inst._defaults.altField) {
				tp_inst.$altInput = $(tp_inst._defaults.altField);
				if (tp_inst._defaults.altRedirectFocus === true) {
					tp_inst.$altInput.css({
						cursor: 'pointer'
					}).focus(function () {
						$input.trigger("focus");
					});
				}
			}

			if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) {
				tp_inst._defaults.minDate = new Date();
			}
			if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) {
				tp_inst._defaults.maxDate = new Date();
			}

			// datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
			if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
				tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
			}
			if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
				tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
			}
			if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
				tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
			}
			if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
				tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
			}
			tp_inst.$input.bind('focus', function () {
				tp_inst._onFocus();
			});

			return tp_inst;
		},

		/*
  * add our sliders to the calendar
  */
		_addTimePicker: function _addTimePicker(dp_inst) {
			var currDT = $.trim(this.$altInput && this._defaults.altFieldTimeOnly ? this.$input.val() + ' ' + this.$altInput.val() : this.$input.val());

			this.timeDefined = this._parseTime(currDT);
			this._limitMinMaxDateTime(dp_inst, false);
			this._injectTimePicker();
			this._afterInject();
		},

		/*
  * parse the time string from input value or _setTime
  */
		_parseTime: function _parseTime(timeString, withDate) {
			if (!this.inst) {
				this.inst = $.datepicker._getInst(this.$input[0]);
			}

			if (withDate || !this._defaults.timeOnly) {
				var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
				try {
					var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
					if (!parseRes.timeObj) {
						return false;
					}
					$.extend(this, parseRes.timeObj);
				} catch (err) {
					$.timepicker.log("Error parsing the date/time string: " + err + "\ndate/time string = " + timeString + "\ntimeFormat = " + this._defaults.timeFormat + "\ndateFormat = " + dp_dateFormat);
					return false;
				}
				return true;
			} else {
				var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
				if (!timeObj) {
					return false;
				}
				$.extend(this, timeObj);
				return true;
			}
		},

		/*
  * Handle callback option after injecting timepicker
  */
		_afterInject: function _afterInject() {
			var o = this.inst.settings;
			if ($.isFunction(o.afterInject)) {
				o.afterInject.call(this);
			}
		},

		/*
  * generate and inject html for timepicker into ui datepicker
  */
		_injectTimePicker: function _injectTimePicker() {
			var $dp = this.inst.dpDiv,
			    o = this.inst.settings,
			    tp_inst = this,
			    litem = '',
			    uitem = '',
			    show = null,
			    max = {},
			    gridSize = {},
			    size = null,
			    i = 0,
			    l = 0;

			// Prevent displaying twice
			if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
				var noDisplay = ' ui_tpicker_unit_hide',
				    html = '<div class="ui-timepicker-div' + (o.isRTL ? ' ui-timepicker-rtl' : '') + (o.oneLine && o.controlType === 'select' ? ' ui-timepicker-oneLine' : '') + '"><dl>' + '<dt class="ui_tpicker_time_label' + (o.showTime ? '' : noDisplay) + '">' + o.timeText + '</dt>' + '<dd class="ui_tpicker_time ' + (o.showTime ? '' : noDisplay) + '"><input class="ui_tpicker_time_input" ' + (o.timeInput ? '' : 'disabled') + '/></dd>';

				// Create the markup
				for (i = 0, l = this.units.length; i < l; i++) {
					litem = this.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// Added by Peter Medeiros:
					// - Figure out what the hour/minute/second max should be based on the step values.
					// - Example: if stepMinute is 15, then minMax is 45.
					max[litem] = parseInt(o[litem + 'Max'] - (o[litem + 'Max'] - o[litem + 'Min']) % o['step' + uitem], 10);
					gridSize[litem] = 0;

					html += '<dt class="ui_tpicker_' + litem + '_label' + (show ? '' : noDisplay) + '">' + o[litem + 'Text'] + '</dt>' + '<dd class="ui_tpicker_' + litem + (show ? '' : noDisplay) + '"><div class="ui_tpicker_' + litem + '_slider' + (show ? '' : noDisplay) + '"></div>';

					if (show && o[litem + 'Grid'] > 0) {
						html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

						if (litem === 'hour') {
							for (var h = o[litem + 'Min']; h <= max[litem]; h += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								var tmph = $.datepicker.formatTime(this.support.ampm ? 'hht' : 'HH', { hour: h }, o);
								html += '<td data-for="' + litem + '">' + tmph + '</td>';
							}
						} else {
							for (var m = o[litem + 'Min']; m <= max[litem]; m += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								html += '<td data-for="' + litem + '">' + (m < 10 ? '0' : '') + m + '</td>';
							}
						}

						html += '</tr></table></div>';
					}
					html += '</dd>';
				}

				// Timezone
				var showTz = o.showTimezone !== null ? o.showTimezone : this.support.timezone;
				html += '<dt class="ui_tpicker_timezone_label' + (showTz ? '' : noDisplay) + '">' + o.timezoneText + '</dt>';
				html += '<dd class="ui_tpicker_timezone' + (showTz ? '' : noDisplay) + '"></dd>';

				// Create the elements from string
				html += '</dl></div>';
				var $tp = $(html);

				// if we only want time picker...
				if (o.timeOnly === true) {
					$tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' + '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' + '</div>');
					$dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
				}

				// add sliders, adjust grids, add events
				for (i = 0, l = tp_inst.units.length; i < l; i++) {
					litem = tp_inst.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// add the slider
					tp_inst[litem + '_slider'] = tp_inst.control.create(tp_inst, $tp.find('.ui_tpicker_' + litem + '_slider'), litem, tp_inst[litem], o[litem + 'Min'], max[litem], o['step' + uitem]);

					// adjust the grid and add click event
					if (show && o[litem + 'Grid'] > 0) {
						size = 100 * gridSize[litem] * o[litem + 'Grid'] / (max[litem] - o[litem + 'Min']);
						$tp.find('.ui_tpicker_' + litem + ' table').css({
							width: size + "%",
							marginLeft: o.isRTL ? '0' : size / (-2 * gridSize[litem]) + "%",
							marginRight: o.isRTL ? size / (-2 * gridSize[litem]) + "%" : '0',
							borderCollapse: 'collapse'
						}).find("td").click(function (e) {
							var $t = $(this),
							    h = $t.html(),
							    n = parseInt(h.replace(/[^0-9]/g), 10),
							    ap = h.replace(/[^apm]/ig),
							    f = $t.data('for'); // loses scope, so we use data-for

							if (f === 'hour') {
								if (ap.indexOf('p') !== -1 && n < 12) {
									n += 12;
								} else {
									if (ap.indexOf('a') !== -1 && n === 12) {
										n = 0;
									}
								}
							}

							tp_inst.control.value(tp_inst, tp_inst[f + '_slider'], litem, n);

							tp_inst._onTimeChange();
							tp_inst._onSelectHandler();
						}).css({
							cursor: 'pointer',
							width: 100 / gridSize[litem] + '%',
							textAlign: 'center',
							overflow: 'hidden'
						});
					} // end if grid > 0
				} // end for loop

				// Add timezone options
				this.timezone_select = $tp.find('.ui_tpicker_timezone').append('<select></select>').find("select");
				$.fn.append.apply(this.timezone_select, $.map(o.timezoneList, function (val, idx) {
					return $("<option />").val((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" ? val.value : val).text((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" ? val.label : val);
				}));
				if (typeof this.timezone !== "undefined" && this.timezone !== null && this.timezone !== "") {
					var local_timezone = new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12).getTimezoneOffset() * -1;
					if (local_timezone === this.timezone) {
						selectLocalTimezone(tp_inst);
					} else {
						this.timezone_select.val(this.timezone);
					}
				} else {
					if (typeof this.hour !== "undefined" && this.hour !== null && this.hour !== "") {
						this.timezone_select.val(o.timezone);
					} else {
						selectLocalTimezone(tp_inst);
					}
				}
				this.timezone_select.change(function () {
					tp_inst._onTimeChange();
					tp_inst._onSelectHandler();
					tp_inst._afterInject();
				});
				// End timezone options

				// inject timepicker into datepicker
				var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
				if ($buttonPanel.length) {
					$buttonPanel.before($tp);
				} else {
					$dp.append($tp);
				}

				this.$timeObj = $tp.find('.ui_tpicker_time_input');
				this.$timeObj.change(function () {
					var timeFormat = tp_inst.inst.settings.timeFormat;
					var parsedTime = $.datepicker.parseTime(timeFormat, this.value);
					var update = new Date();
					if (parsedTime) {
						update.setHours(parsedTime.hour);
						update.setMinutes(parsedTime.minute);
						update.setSeconds(parsedTime.second);
						$.datepicker._setTime(tp_inst.inst, update);
					} else {
						this.value = tp_inst.formattedTime;
						this.blur();
					}
				});

				if (this.inst !== null) {
					var timeDefined = this.timeDefined;
					this._onTimeChange();
					this.timeDefined = timeDefined;
				}

				// slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
				if (this._defaults.addSliderAccess) {
					var sliderAccessArgs = this._defaults.sliderAccessArgs,
					    rtl = this._defaults.isRTL;
					sliderAccessArgs.isRTL = rtl;

					setTimeout(function () {
						// fix for inline mode
						if ($tp.find('.ui-slider-access').length === 0) {
							$tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

							// fix any grids since sliders are shorter
							var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
							if (sliderAccessWidth) {
								$tp.find('table:visible').each(function () {
									var $g = $(this),
									    oldWidth = $g.outerWidth(),
									    oldMarginLeft = $g.css(rtl ? 'marginRight' : 'marginLeft').toString().replace('%', ''),
									    newWidth = oldWidth - sliderAccessWidth,
									    newMarginLeft = oldMarginLeft * newWidth / oldWidth + '%',
									    css = { width: newWidth, marginRight: 0, marginLeft: 0 };
									css[rtl ? 'marginRight' : 'marginLeft'] = newMarginLeft;
									$g.css(css);
								});
							}
						}
					}, 10);
				}
				// end slideAccess integration

				tp_inst._limitMinMaxDateTime(this.inst, true);
			}
		},

		/*
  * This function tries to limit the ability to go outside the
  * min/max date range
  */
		_limitMinMaxDateTime: function _limitMinMaxDateTime(dp_inst, adjustSliders) {
			var o = this._defaults,
			    dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

			if (!this._defaults.showTimepicker) {
				return;
			} // No time so nothing to check here

			if ($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date) {
				var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
				    minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null || this.microsecMinOriginal === null) {
					this.hourMinOriginal = o.hourMin;
					this.minuteMinOriginal = o.minuteMin;
					this.secondMinOriginal = o.secondMin;
					this.millisecMinOriginal = o.millisecMin;
					this.microsecMinOriginal = o.microsecMin;
				}

				if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMin = minDateTime.getHours();
					if (this.hour <= this._defaults.hourMin) {
						this.hour = this._defaults.hourMin;
						this._defaults.minuteMin = minDateTime.getMinutes();
						if (this.minute <= this._defaults.minuteMin) {
							this.minute = this._defaults.minuteMin;
							this._defaults.secondMin = minDateTime.getSeconds();
							if (this.second <= this._defaults.secondMin) {
								this.second = this._defaults.secondMin;
								this._defaults.millisecMin = minDateTime.getMilliseconds();
								if (this.millisec <= this._defaults.millisecMin) {
									this.millisec = this._defaults.millisecMin;
									this._defaults.microsecMin = minDateTime.getMicroseconds();
								} else {
									if (this.microsec < this._defaults.microsecMin) {
										this.microsec = this._defaults.microsecMin;
									}
									this._defaults.microsecMin = this.microsecMinOriginal;
								}
							} else {
								this._defaults.millisecMin = this.millisecMinOriginal;
								this._defaults.microsecMin = this.microsecMinOriginal;
							}
						} else {
							this._defaults.secondMin = this.secondMinOriginal;
							this._defaults.millisecMin = this.millisecMinOriginal;
							this._defaults.microsecMin = this.microsecMinOriginal;
						}
					} else {
						this._defaults.minuteMin = this.minuteMinOriginal;
						this._defaults.secondMin = this.secondMinOriginal;
						this._defaults.millisecMin = this.millisecMinOriginal;
						this._defaults.microsecMin = this.microsecMinOriginal;
					}
				} else {
					this._defaults.hourMin = this.hourMinOriginal;
					this._defaults.minuteMin = this.minuteMinOriginal;
					this._defaults.secondMin = this.secondMinOriginal;
					this._defaults.millisecMin = this.millisecMinOriginal;
					this._defaults.microsecMin = this.microsecMinOriginal;
				}
			}

			if ($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date) {
				var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
				    maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null || this.millisecMaxOriginal === null) {
					this.hourMaxOriginal = o.hourMax;
					this.minuteMaxOriginal = o.minuteMax;
					this.secondMaxOriginal = o.secondMax;
					this.millisecMaxOriginal = o.millisecMax;
					this.microsecMaxOriginal = o.microsecMax;
				}

				if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMax = maxDateTime.getHours();
					if (this.hour >= this._defaults.hourMax) {
						this.hour = this._defaults.hourMax;
						this._defaults.minuteMax = maxDateTime.getMinutes();
						if (this.minute >= this._defaults.minuteMax) {
							this.minute = this._defaults.minuteMax;
							this._defaults.secondMax = maxDateTime.getSeconds();
							if (this.second >= this._defaults.secondMax) {
								this.second = this._defaults.secondMax;
								this._defaults.millisecMax = maxDateTime.getMilliseconds();
								if (this.millisec >= this._defaults.millisecMax) {
									this.millisec = this._defaults.millisecMax;
									this._defaults.microsecMax = maxDateTime.getMicroseconds();
								} else {
									if (this.microsec > this._defaults.microsecMax) {
										this.microsec = this._defaults.microsecMax;
									}
									this._defaults.microsecMax = this.microsecMaxOriginal;
								}
							} else {
								this._defaults.millisecMax = this.millisecMaxOriginal;
								this._defaults.microsecMax = this.microsecMaxOriginal;
							}
						} else {
							this._defaults.secondMax = this.secondMaxOriginal;
							this._defaults.millisecMax = this.millisecMaxOriginal;
							this._defaults.microsecMax = this.microsecMaxOriginal;
						}
					} else {
						this._defaults.minuteMax = this.minuteMaxOriginal;
						this._defaults.secondMax = this.secondMaxOriginal;
						this._defaults.millisecMax = this.millisecMaxOriginal;
						this._defaults.microsecMax = this.microsecMaxOriginal;
					}
				} else {
					this._defaults.hourMax = this.hourMaxOriginal;
					this._defaults.minuteMax = this.minuteMaxOriginal;
					this._defaults.secondMax = this.secondMaxOriginal;
					this._defaults.millisecMax = this.millisecMaxOriginal;
					this._defaults.microsecMax = this.microsecMaxOriginal;
				}
			}

			if (dp_inst.settings.minTime !== null) {
				var tempMinTime = new Date("01/01/1970 " + dp_inst.settings.minTime);
				if (this.hour < tempMinTime.getHours()) {
					this.hour = this._defaults.hourMin = tempMinTime.getHours();
					this.minute = this._defaults.minuteMin = tempMinTime.getMinutes();
				} else if (this.hour === tempMinTime.getHours() && this.minute < tempMinTime.getMinutes()) {
					this.minute = this._defaults.minuteMin = tempMinTime.getMinutes();
				} else {
					if (this._defaults.hourMin < tempMinTime.getHours()) {
						this._defaults.hourMin = tempMinTime.getHours();
						this._defaults.minuteMin = tempMinTime.getMinutes();
					} else if (this._defaults.hourMin === tempMinTime.getHours() === this.hour && this._defaults.minuteMin < tempMinTime.getMinutes()) {
						this._defaults.minuteMin = tempMinTime.getMinutes();
					} else {
						this._defaults.minuteMin = 0;
					}
				}
			}

			if (dp_inst.settings.maxTime !== null) {
				var tempMaxTime = new Date("01/01/1970 " + dp_inst.settings.maxTime);
				if (this.hour > tempMaxTime.getHours()) {
					this.hour = this._defaults.hourMax = tempMaxTime.getHours();
					this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes();
				} else if (this.hour === tempMaxTime.getHours() && this.minute > tempMaxTime.getMinutes()) {
					this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes();
				} else {
					if (this._defaults.hourMax > tempMaxTime.getHours()) {
						this._defaults.hourMax = tempMaxTime.getHours();
						this._defaults.minuteMax = tempMaxTime.getMinutes();
					} else if (this._defaults.hourMax === tempMaxTime.getHours() === this.hour && this._defaults.minuteMax > tempMaxTime.getMinutes()) {
						this._defaults.minuteMax = tempMaxTime.getMinutes();
					} else {
						this._defaults.minuteMax = 59;
					}
				}
			}

			if (adjustSliders !== undefined && adjustSliders === true) {
				var hourMax = parseInt(this._defaults.hourMax - (this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour, 10),
				    minMax = parseInt(this._defaults.minuteMax - (this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute, 10),
				    secMax = parseInt(this._defaults.secondMax - (this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond, 10),
				    millisecMax = parseInt(this._defaults.millisecMax - (this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec, 10),
				    microsecMax = parseInt(this._defaults.microsecMax - (this._defaults.microsecMax - this._defaults.microsecMin) % this._defaults.stepMicrosec, 10);

				if (this.hour_slider) {
					this.control.options(this, this.hour_slider, 'hour', { min: this._defaults.hourMin, max: hourMax, step: this._defaults.stepHour });
					this.control.value(this, this.hour_slider, 'hour', this.hour - this.hour % this._defaults.stepHour);
				}
				if (this.minute_slider) {
					this.control.options(this, this.minute_slider, 'minute', { min: this._defaults.minuteMin, max: minMax, step: this._defaults.stepMinute });
					this.control.value(this, this.minute_slider, 'minute', this.minute - this.minute % this._defaults.stepMinute);
				}
				if (this.second_slider) {
					this.control.options(this, this.second_slider, 'second', { min: this._defaults.secondMin, max: secMax, step: this._defaults.stepSecond });
					this.control.value(this, this.second_slider, 'second', this.second - this.second % this._defaults.stepSecond);
				}
				if (this.millisec_slider) {
					this.control.options(this, this.millisec_slider, 'millisec', { min: this._defaults.millisecMin, max: millisecMax, step: this._defaults.stepMillisec });
					this.control.value(this, this.millisec_slider, 'millisec', this.millisec - this.millisec % this._defaults.stepMillisec);
				}
				if (this.microsec_slider) {
					this.control.options(this, this.microsec_slider, 'microsec', { min: this._defaults.microsecMin, max: microsecMax, step: this._defaults.stepMicrosec });
					this.control.value(this, this.microsec_slider, 'microsec', this.microsec - this.microsec % this._defaults.stepMicrosec);
				}
			}
		},

		/*
  * when a slider moves, set the internal time...
  * on time change is also called when the time is updated in the text field
  */
		_onTimeChange: function _onTimeChange() {
			if (!this._defaults.showTimepicker) {
				return;
			}
			var hour = this.hour_slider ? this.control.value(this, this.hour_slider, 'hour') : false,
			    minute = this.minute_slider ? this.control.value(this, this.minute_slider, 'minute') : false,
			    second = this.second_slider ? this.control.value(this, this.second_slider, 'second') : false,
			    millisec = this.millisec_slider ? this.control.value(this, this.millisec_slider, 'millisec') : false,
			    microsec = this.microsec_slider ? this.control.value(this, this.microsec_slider, 'microsec') : false,
			    timezone = this.timezone_select ? this.timezone_select.val() : false,
			    o = this._defaults,
			    pickerTimeFormat = o.pickerTimeFormat || o.timeFormat,
			    pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;

			if ((typeof hour === 'undefined' ? 'undefined' : _typeof(hour)) === 'object') {
				hour = false;
			}
			if ((typeof minute === 'undefined' ? 'undefined' : _typeof(minute)) === 'object') {
				minute = false;
			}
			if ((typeof second === 'undefined' ? 'undefined' : _typeof(second)) === 'object') {
				second = false;
			}
			if ((typeof millisec === 'undefined' ? 'undefined' : _typeof(millisec)) === 'object') {
				millisec = false;
			}
			if ((typeof microsec === 'undefined' ? 'undefined' : _typeof(microsec)) === 'object') {
				microsec = false;
			}
			if ((typeof timezone === 'undefined' ? 'undefined' : _typeof(timezone)) === 'object') {
				timezone = false;
			}

			if (hour !== false) {
				hour = parseInt(hour, 10);
			}
			if (minute !== false) {
				minute = parseInt(minute, 10);
			}
			if (second !== false) {
				second = parseInt(second, 10);
			}
			if (millisec !== false) {
				millisec = parseInt(millisec, 10);
			}
			if (microsec !== false) {
				microsec = parseInt(microsec, 10);
			}
			if (timezone !== false) {
				timezone = timezone.toString();
			}

			var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

			// If the update was done in the input field, the input field should not be updated.
			// If the update was done using the sliders, update the input field.
			var hasChanged = hour !== parseInt(this.hour, 10) || // sliders should all be numeric
			minute !== parseInt(this.minute, 10) || second !== parseInt(this.second, 10) || millisec !== parseInt(this.millisec, 10) || microsec !== parseInt(this.microsec, 10) || this.ampm.length > 0 && hour < 12 !== ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1) || this.timezone !== null && timezone !== this.timezone.toString() // could be numeric or "EST" format, so use toString()
			;

			if (hasChanged) {

				if (hour !== false) {
					this.hour = hour;
				}
				if (minute !== false) {
					this.minute = minute;
				}
				if (second !== false) {
					this.second = second;
				}
				if (millisec !== false) {
					this.millisec = millisec;
				}
				if (microsec !== false) {
					this.microsec = microsec;
				}
				if (timezone !== false) {
					this.timezone = timezone;
				}

				if (!this.inst) {
					this.inst = $.datepicker._getInst(this.$input[0]);
				}

				this._limitMinMaxDateTime(this.inst, true);
			}
			if (this.support.ampm) {
				this.ampm = ampm;
			}

			// Updates the time within the timepicker
			this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o);
			if (this.$timeObj) {
				if (pickerTimeFormat === o.timeFormat) {
					this.$timeObj.val(this.formattedTime + pickerTimeSuffix);
				} else {
					this.$timeObj.val($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix);
				}
				if (this.$timeObj[0].setSelectionRange) {
					var sPos = this.$timeObj[0].selectionStart;
					var ePos = this.$timeObj[0].selectionEnd;
					this.$timeObj[0].setSelectionRange(sPos, ePos);
				}
			}

			this.timeDefined = true;
			if (hasChanged) {
				this._updateDateTime();
				//this.$input.focus(); // may automatically open the picker on setDate
			}
		},

		/*
  * call custom onSelect.
  * bind to sliders slidestop, and grid click.
  */
		_onSelectHandler: function _onSelectHandler() {
			var onSelect = this._defaults.onSelect || this.inst.settings.onSelect;
			var inputEl = this.$input ? this.$input[0] : null;
			if (onSelect && inputEl) {
				onSelect.apply(inputEl, [this.formattedDateTime, this]);
			}
		},

		/*
  * update our input with the new date time..
  */
		_updateDateTime: function _updateDateTime(dp_inst) {
			dp_inst = this.inst || dp_inst;
			var dtTmp = dp_inst.currentYear > 0 ? new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay) : new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay),
			    dt = $.datepicker._daylightSavingAdjust(dtTmp),

			//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
			//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay)),
			dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
			    formatCfg = $.datepicker._getFormatConfig(dp_inst),
			    timeAvailable = dt !== null && this.timeDefined;
			this.formattedDate = $.datepicker.formatDate(dateFmt, dt === null ? new Date() : dt, formatCfg);
			var formattedDateTime = this.formattedDate;

			// if a slider was changed but datepicker doesn't have a value yet, set it
			if (dp_inst.lastVal === "") {
				dp_inst.currentYear = dp_inst.selectedYear;
				dp_inst.currentMonth = dp_inst.selectedMonth;
				dp_inst.currentDay = dp_inst.selectedDay;
			}

			/*
   * remove following lines to force every changes in date picker to change the input value
   * Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker.
   * If the user manually empty the value in the input field, the date picker will never change selected value.
   */
			//if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
			//	return;
			//}

			if (this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === false) {
				formattedDateTime = this.formattedTime;
			} else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable) || this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === true) {
				formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
			}

			this.formattedDateTime = formattedDateTime;

			if (!this._defaults.showTimepicker) {
				this.$input.val(this.formattedDate);
			} else if (this.$altInput && this._defaults.timeOnly === false && this._defaults.altFieldTimeOnly === true) {
				this.$altInput.val(this.formattedTime);
				this.$input.val(this.formattedDate);
			} else if (this.$altInput) {
				this.$input.val(formattedDateTime);
				var altFormattedDateTime = '',
				    altSeparator = this._defaults.altSeparator !== null ? this._defaults.altSeparator : this._defaults.separator,
				    altTimeSuffix = this._defaults.altTimeSuffix !== null ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;

				if (!this._defaults.timeOnly) {
					if (this._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, dt === null ? new Date() : dt, formatCfg);
					} else {
						altFormattedDateTime = this.formattedDate;
					}

					if (altFormattedDateTime) {
						altFormattedDateTime += altSeparator;
					}
				}

				if (this._defaults.altTimeFormat !== null) {
					altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix;
				} else {
					altFormattedDateTime += this.formattedTime + altTimeSuffix;
				}
				this.$altInput.val(altFormattedDateTime);
			} else {
				this.$input.val(formattedDateTime);
			}

			this.$input.trigger("change");
		},

		_onFocus: function _onFocus() {
			if (!this.$input.val() && this._defaults.defaultValue) {
				this.$input.val(this._defaults.defaultValue);
				var inst = $.datepicker._getInst(this.$input.get(0)),
				    tp_inst = $.datepicker._get(inst, 'timepicker');
				if (tp_inst) {
					if (tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) {
						try {
							$.datepicker._updateDatepicker(inst);
						} catch (err) {
							$.timepicker.log(err);
						}
					}
				}
			}
		},

		/*
  * Small abstraction to control types
  * We can add more, just be sure to follow the pattern: create, options, value
  */
		_controls: {
			// slider methods
			slider: {
				create: function create(tp_inst, obj, unit, val, min, max, step) {
					var rtl = tp_inst._defaults.isRTL; // if rtl go -60->0 instead of 0->60
					return obj.prop('slide', null).slider({
						orientation: "horizontal",
						value: rtl ? val * -1 : val,
						min: rtl ? max * -1 : min,
						max: rtl ? min * -1 : max,
						step: step,
						slide: function slide(event, ui) {
							tp_inst.control.value(tp_inst, $(this), unit, rtl ? ui.value * -1 : ui.value);
							tp_inst._onTimeChange();
						},
						stop: function stop(event, ui) {
							tp_inst._onSelectHandler();
						}
					});
				},
				options: function options(tp_inst, obj, unit, opts, val) {
					if (tp_inst._defaults.isRTL) {
						if (typeof opts === 'string') {
							if (opts === 'min' || opts === 'max') {
								if (val !== undefined) {
									return obj.slider(opts, val * -1);
								}
								return Math.abs(obj.slider(opts));
							}
							return obj.slider(opts);
						}
						var min = opts.min,
						    max = opts.max;
						opts.min = opts.max = null;
						if (min !== undefined) {
							opts.max = min * -1;
						}
						if (max !== undefined) {
							opts.min = max * -1;
						}
						return obj.slider(opts);
					}
					if (typeof opts === 'string' && val !== undefined) {
						return obj.slider(opts, val);
					}
					return obj.slider(opts);
				},
				value: function value(tp_inst, obj, unit, val) {
					if (tp_inst._defaults.isRTL) {
						if (val !== undefined) {
							return obj.slider('value', val * -1);
						}
						return Math.abs(obj.slider('value'));
					}
					if (val !== undefined) {
						return obj.slider('value', val);
					}
					return obj.slider('value');
				}
			},
			// select methods
			select: {
				create: function create(tp_inst, obj, unit, val, min, max, step) {
					var sel = '<select class="ui-timepicker-select ui-state-default ui-corner-all" data-unit="' + unit + '" data-min="' + min + '" data-max="' + max + '" data-step="' + step + '">',
					    format = tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat;

					for (var i = min; i <= max; i += step) {
						sel += '<option value="' + i + '"' + (i === val ? ' selected' : '') + '>';
						if (unit === 'hour') {
							sel += $.datepicker.formatTime($.trim(format.replace(/[^ht ]/ig, '')), { hour: i }, tp_inst._defaults);
						} else if (unit === 'millisec' || unit === 'microsec' || i >= 10) {
							sel += i;
						} else {
							sel += '0' + i.toString();
						}
						sel += '</option>';
					}
					sel += '</select>';

					obj.children('select').remove();

					$(sel).appendTo(obj).change(function (e) {
						tp_inst._onTimeChange();
						tp_inst._onSelectHandler();
						tp_inst._afterInject();
					});

					return obj;
				},
				options: function options(tp_inst, obj, unit, opts, val) {
					var o = {},
					    $t = obj.children('select');
					if (typeof opts === 'string') {
						if (val === undefined) {
							return $t.data(opts);
						}
						o[opts] = val;
					} else {
						o = opts;
					}
					return tp_inst.control.create(tp_inst, obj, $t.data('unit'), $t.val(), o.min >= 0 ? o.min : $t.data('min'), o.max || $t.data('max'), o.step || $t.data('step'));
				},
				value: function value(tp_inst, obj, unit, val) {
					var $t = obj.children('select');
					if (val !== undefined) {
						return $t.val(val);
					}
					return $t.val();
				}
			} // end _controls

		} });

	$.fn.extend({
		/*
  * shorthand just to use timepicker.
  */
		timepicker: function timepicker(o) {
			o = o || {};
			var tmp_args = Array.prototype.slice.call(arguments);

			if ((typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object') {
				tmp_args[0] = $.extend(o, {
					timeOnly: true
				});
			}

			return $(this).each(function () {
				$.fn.datetimepicker.apply($(this), tmp_args);
			});
		},

		/*
  * extend timepicker to datepicker
  */
		datetimepicker: function datetimepicker(o) {
			o = o || {};
			var tmp_args = arguments;

			if (typeof o === 'string') {
				if (o === 'getDate' || o === 'option' && tmp_args.length === 2 && typeof tmp_args[1] === 'string') {
					return $.fn.datepicker.apply($(this[0]), tmp_args);
				} else {
					return this.each(function () {
						var $t = $(this);
						$t.datepicker.apply($t, tmp_args);
					});
				}
			} else {
				return this.each(function () {
					var $t = $(this);
					$t.datepicker($.timepicker._newInst($t, o)._defaults);
				});
			}
		}
	});

	/*
 * Public Utility to parse date and time
 */
	$.datepicker.parseDateTime = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
		if (parseRes.timeObj) {
			var t = parseRes.timeObj;
			parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
			parseRes.date.setMicroseconds(t.microsec);
		}

		return parseRes.date;
	};

	/*
 * Public utility to parse time
 */
	$.datepicker.parseTime = function (timeFormat, timeString, options) {
		var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}),
		    iso8601 = timeFormat.replace(/\'.*?\'/g, '').indexOf('Z') !== -1;

		// Strict parse requires the timeString to match the timeFormat exactly
		var strictParse = function strictParse(f, s, o) {

			// pattern for standard and localized AM/PM markers
			var getPatternAmpm = function getPatternAmpm(amNames, pmNames) {
				var markers = [];
				if (amNames) {
					$.merge(markers, amNames);
				}
				if (pmNames) {
					$.merge(markers, pmNames);
				}
				markers = $.map(markers, function (val) {
					return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&');
				});
				return '(' + markers.join('|') + ')?';
			};

			// figure out position of time elements.. cause js cant do named captures
			var getFormatPositions = function getFormatPositions(timeFormat) {
				var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g),
				    orders = {
					h: -1,
					m: -1,
					s: -1,
					l: -1,
					c: -1,
					t: -1,
					z: -1
				};

				if (finds) {
					for (var i = 0; i < finds.length; i++) {
						if (orders[finds[i].toString().charAt(0)] === -1) {
							orders[finds[i].toString().charAt(0)] = i + 1;
						}
					}
				}
				return orders;
			};

			var regstr = '^' + f.toString().replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
				var ml = match.length;
				switch (match.charAt(0).toLowerCase()) {
					case 'h':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 'm':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 's':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 'l':
						return '(\\d?\\d?\\d)';
					case 'c':
						return '(\\d?\\d?\\d)';
					case 'z':
						return '(z|[-+]\\d\\d:?\\d\\d|\\S+)?';
					case 't':
						return getPatternAmpm(o.amNames, o.pmNames);
					default:
						// literal escaped in quotes
						return '(' + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function (m) {
							return "\\" + m;
						}) + ')?';
				}
			}).replace(/\s/g, '\\s?') + o.timeSuffix + '$',
			    order = getFormatPositions(f),
			    ampm = '',
			    treg;

			treg = s.match(new RegExp(regstr, 'i'));

			var resTime = {
				hour: 0,
				minute: 0,
				second: 0,
				millisec: 0,
				microsec: 0
			};

			if (treg) {
				if (order.t !== -1) {
					if (treg[order.t] === undefined || treg[order.t].length === 0) {
						ampm = '';
						resTime.ampm = '';
					} else {
						ampm = $.inArray(treg[order.t].toUpperCase(), $.map(o.amNames, function (x, i) {
							return x.toUpperCase();
						})) !== -1 ? 'AM' : 'PM';
						resTime.ampm = o[ampm === 'AM' ? 'amNames' : 'pmNames'][0];
					}
				}

				if (order.h !== -1) {
					if (ampm === 'AM' && treg[order.h] === '12') {
						resTime.hour = 0; // 12am = 0 hour
					} else {
						if (ampm === 'PM' && treg[order.h] !== '12') {
							resTime.hour = parseInt(treg[order.h], 10) + 12; // 12pm = 12 hour, any other pm = hour + 12
						} else {
							resTime.hour = Number(treg[order.h]);
						}
					}
				}

				if (order.m !== -1) {
					resTime.minute = Number(treg[order.m]);
				}
				if (order.s !== -1) {
					resTime.second = Number(treg[order.s]);
				}
				if (order.l !== -1) {
					resTime.millisec = Number(treg[order.l]);
				}
				if (order.c !== -1) {
					resTime.microsec = Number(treg[order.c]);
				}
				if (order.z !== -1 && treg[order.z] !== undefined) {
					resTime.timezone = $.timepicker.timezoneOffsetNumber(treg[order.z]);
				}

				return resTime;
			}
			return false;
		}; // end strictParse

		// First try JS Date, if that fails, use strictParse
		var looseParse = function looseParse(f, s, o) {
			try {
				var d = new Date('2012-01-01 ' + s);
				if (isNaN(d.getTime())) {
					d = new Date('2012-01-01T' + s);
					if (isNaN(d.getTime())) {
						d = new Date('01/01/2012 ' + s);
						if (isNaN(d.getTime())) {
							throw "Unable to parse time with native Date: " + s;
						}
					}
				}

				return {
					hour: d.getHours(),
					minute: d.getMinutes(),
					second: d.getSeconds(),
					millisec: d.getMilliseconds(),
					microsec: d.getMicroseconds(),
					timezone: d.getTimezoneOffset() * -1
				};
			} catch (err) {
				try {
					return strictParse(f, s, o);
				} catch (err2) {
					$.timepicker.log("Unable to parse \ntimeString: " + s + "\ntimeFormat: " + f);
				}
			}
			return false;
		}; // end looseParse

		if (typeof o.parse === "function") {
			return o.parse(timeFormat, timeString, o);
		}
		if (o.parse === 'loose') {
			return looseParse(timeFormat, timeString, o);
		}
		return strictParse(timeFormat, timeString, o);
	};

	/**
  * Public utility to format the time
  * @param {string} format format of the time
  * @param {Object} time Object not a Date for timezones
  * @param {Object} [options] essentially the regional[].. amNames, pmNames, ampm
  * @returns {string} the formatted time
  */
	$.datepicker.formatTime = function (format, time, options) {
		options = options || {};
		options = $.extend({}, $.timepicker._defaults, options);
		time = $.extend({
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null
		}, time);

		var tmptime = format,
		    ampmName = options.amNames[0],
		    hour = parseInt(time.hour, 10);

		if (hour > 11) {
			ampmName = options.pmNames[0];
		}

		tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
			switch (match) {
				case 'HH':
					return ('0' + hour).slice(-2);
				case 'H':
					return hour;
				case 'hh':
					return ('0' + convert24to12(hour)).slice(-2);
				case 'h':
					return convert24to12(hour);
				case 'mm':
					return ('0' + time.minute).slice(-2);
				case 'm':
					return time.minute;
				case 'ss':
					return ('0' + time.second).slice(-2);
				case 's':
					return time.second;
				case 'l':
					return ('00' + time.millisec).slice(-3);
				case 'c':
					return ('00' + time.microsec).slice(-3);
				case 'z':
					return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, false);
				case 'Z':
					return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, true);
				case 'T':
					return ampmName.charAt(0).toUpperCase();
				case 'TT':
					return ampmName.toUpperCase();
				case 't':
					return ampmName.charAt(0).toLowerCase();
				case 'tt':
					return ampmName.toLowerCase();
				default:
					return match.replace(/'/g, "");
			}
		});

		return tmptime;
	};

	/*
 * the bad hack :/ override datepicker so it doesn't close on select
 // inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
 */
	$.datepicker._base_selectDate = $.datepicker._selectDate;
	$.datepicker._selectDate = function (id, dateStr) {
		var inst = this._getInst($(id)[0]),
		    tp_inst = this._get(inst, 'timepicker'),
		    was_inline;

		if (tp_inst && inst.settings.showTimepicker) {
			tp_inst._limitMinMaxDateTime(inst, true);
			was_inline = inst.inline;
			inst.inline = inst.stay_open = true;
			//This way the onSelect handler called from calendarpicker get the full dateTime
			this._base_selectDate(id, dateStr);
			inst.inline = was_inline;
			inst.stay_open = false;
			this._notifyChange(inst);
			this._updateDatepicker(inst);
		} else {
			this._base_selectDate(id, dateStr);
		}
	};

	/*
 * second bad hack :/ override datepicker so it triggers an event when changing the input field
 * and does not redraw the datepicker on every selectDate event
 */
	$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
	$.datepicker._updateDatepicker = function (inst) {

		// don't popup the datepicker if there is another instance already opened
		var input = inst.input[0];
		if ($.datepicker._curInst && $.datepicker._curInst !== inst && $.datepicker._datepickerShowing && $.datepicker._lastInput !== input) {
			return;
		}

		if (typeof inst.stay_open !== 'boolean' || inst.stay_open === false) {

			this._base_updateDatepicker(inst);

			// Reload the time control when changing something in the input text field.
			var tp_inst = this._get(inst, 'timepicker');
			if (tp_inst) {
				tp_inst._addTimePicker(inst);
			}
		}
	};

	/*
 * third bad hack :/ override datepicker so it allows spaces and colon in the input field
 */
	$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
	$.datepicker._doKeyPress = function (event) {
		var inst = $.datepicker._getInst(event.target),
		    tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if ($.datepicker._get(inst, 'constrainInput')) {
				var ampm = tp_inst.support.ampm,
				    tz = tp_inst._defaults.showTimezone !== null ? tp_inst._defaults.showTimezone : tp_inst.support.timezone,
				    dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
				    datetimeChars = tp_inst._defaults.timeFormat.toString().replace(/[hms]/g, '').replace(/TT/g, ampm ? 'APM' : '').replace(/Tt/g, ampm ? 'AaPpMm' : '').replace(/tT/g, ampm ? 'AaPpMm' : '').replace(/T/g, ampm ? 'AP' : '').replace(/tt/g, ampm ? 'apm' : '').replace(/t/g, ampm ? 'ap' : '') + " " + tp_inst._defaults.separator + tp_inst._defaults.timeSuffix + (tz ? tp_inst._defaults.timezoneList.join('') : '') + tp_inst._defaults.amNames.join('') + tp_inst._defaults.pmNames.join('') + dateChars,
				    chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
				return event.ctrlKey || chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1;
			}
		}

		return $.datepicker._base_doKeyPress(event);
	};

	/*
 * Fourth bad hack :/ override _updateAlternate function used in inline mode to init altField
 * Update any alternate field to synchronise with the main field.
 */
	$.datepicker._base_updateAlternate = $.datepicker._updateAlternate;
	$.datepicker._updateAlternate = function (inst) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var altField = tp_inst._defaults.altField;
			if (altField) {
				// update alternate field too
				var altFormat = tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat,
				    date = this._getDate(inst),
				    formatCfg = $.datepicker._getFormatConfig(inst),
				    altFormattedDateTime = '',
				    altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator,
				    altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix,
				    altTimeFormat = tp_inst._defaults.altTimeFormat !== null ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;

				altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix;
				if (!tp_inst._defaults.timeOnly && !tp_inst._defaults.altFieldTimeOnly && date !== null) {
					if (tp_inst._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime;
					} else {
						altFormattedDateTime = tp_inst.formattedDate + altSeparator + altFormattedDateTime;
					}
				}
				$(altField).val(inst.input.val() ? altFormattedDateTime : "");
			}
		} else {
			$.datepicker._base_updateAlternate(inst);
		}
	};

	/*
 * Override key up event to sync manual input changes.
 */
	$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
	$.datepicker._doKeyUp = function (event) {
		var inst = $.datepicker._getInst(event.target),
		    tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if (tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) {
				try {
					$.datepicker._updateDatepicker(inst);
				} catch (err) {
					$.timepicker.log(err);
				}
			}
		}

		return $.datepicker._base_doKeyUp(event);
	};

	/*
 * override "Today" button to also grab the time and set it to input field.
 */
	$.datepicker._base_gotoToday = $.datepicker._gotoToday;
	$.datepicker._gotoToday = function (id) {
		var inst = this._getInst($(id)[0]);
		this._base_gotoToday(id);
		var tp_inst = this._get(inst, 'timepicker');
		if (!tp_inst) {
			return;
		}

		var tzoffset = $.timepicker.timezoneOffsetNumber(tp_inst.timezone);
		var now = new Date();
		now.setMinutes(now.getMinutes() + now.getTimezoneOffset() + parseInt(tzoffset, 10));
		this._setTime(inst, now);
		this._setDate(inst, now);
		tp_inst._onSelectHandler();
	};

	/*
 * Disable & enable the Time in the datetimepicker
 */
	$.datepicker._disableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = false;
			tp_inst._defaults.showTimepicker = false;
			tp_inst._updateDateTime(inst);
		}
	};

	$.datepicker._enableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = true;
			tp_inst._defaults.showTimepicker = true;
			tp_inst._addTimePicker(inst); // Could be disabled on page load
			tp_inst._updateDateTime(inst);
		}
	};

	/*
 * Create our own set time function
 */
	$.datepicker._setTime = function (inst, date) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var defaults = tp_inst._defaults;

			// calling _setTime with no date sets time to defaults
			tp_inst.hour = date ? date.getHours() : defaults.hour;
			tp_inst.minute = date ? date.getMinutes() : defaults.minute;
			tp_inst.second = date ? date.getSeconds() : defaults.second;
			tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec;
			tp_inst.microsec = date ? date.getMicroseconds() : defaults.microsec;

			//check if within min/max times..
			tp_inst._limitMinMaxDateTime(inst, true);

			tp_inst._onTimeChange();
			tp_inst._updateDateTime(inst);
		}
	};

	/*
 * Create new public method to set only time, callable as $().datepicker('setTime', date)
 */
	$.datepicker._setTimeDatepicker = function (target, date, withDate) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			this._setDateFromField(inst);
			var tp_date;
			if (date) {
				if (typeof date === "string") {
					tp_inst._parseTime(date, withDate);
					tp_date = new Date();
					tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
					tp_date.setMicroseconds(tp_inst.microsec);
				} else {
					tp_date = new Date(date.getTime());
					tp_date.setMicroseconds(date.getMicroseconds());
				}
				if (tp_date.toString() === 'Invalid Date') {
					tp_date = undefined;
				}
				this._setTime(inst, tp_date);
			}
		}
	};

	/*
 * override setDate() to allow setting time too within Date object
 */
	$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
	$.datepicker._setDateDatepicker = function (target, _date) {
		var inst = this._getInst(target);
		var date = _date;
		if (!inst) {
			return;
		}

		if (typeof _date === 'string') {
			date = new Date(_date);
			if (!date.getTime()) {
				this._base_setDateDatepicker.apply(this, arguments);
				date = $(target).datepicker('getDate');
			}
		}

		var tp_inst = this._get(inst, 'timepicker');
		var tp_date;
		if (date instanceof Date) {
			tp_date = new Date(date.getTime());
			tp_date.setMicroseconds(date.getMicroseconds());
		} else {
			tp_date = date;
		}

		// This is important if you are using the timezone option, javascript's Date
		// object will only return the timezone offset for the current locale, so we
		// adjust it accordingly.  If not using timezone option this won't matter..
		// If a timezone is different in tp, keep the timezone as is
		if (tp_inst && tp_date) {
			// look out for DST if tz wasn't specified
			if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
				tp_inst.timezone = tp_date.getTimezoneOffset() * -1;
			}
			date = $.timepicker.timezoneAdjust(date, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()), tp_inst.timezone);
			tp_date = $.timepicker.timezoneAdjust(tp_date, $.timepicker.timezoneOffsetString(-tp_date.getTimezoneOffset()), tp_inst.timezone);
		}

		this._updateDatepicker(inst);
		this._base_setDateDatepicker.apply(this, arguments);
		this._setTimeDatepicker(target, tp_date, true);
	};

	/*
 * override getDate() to allow getting time too within Date object
 */
	$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
	$.datepicker._getDateDatepicker = function (target, noDefault) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			// if it hasn't yet been defined, grab from field
			if (inst.lastVal === undefined) {
				this._setDateFromField(inst, noDefault);
			}

			var date = this._getDate(inst);

			var currDT = null;

			if (tp_inst.$altInput && tp_inst._defaults.altFieldTimeOnly) {
				currDT = tp_inst.$input.val() + ' ' + tp_inst.$altInput.val();
			} else if (tp_inst.$input.get(0).tagName !== 'INPUT' && tp_inst.$altInput) {
				/**
     * in case the datetimepicker has been applied to a non-input tag for inline UI,
     * and the user has not configured the plugin to display only time in altInput,
     * pick current date time from the altInput (and hope for the best, for now, until "ER1" is applied)
     *
     * @todo ER1. Since altInput can have a totally difference format, convert it to standard format by reading input format from "altFormat" and "altTimeFormat" option values
     */
				currDT = tp_inst.$altInput.val();
			} else {
				currDT = tp_inst.$input.val();
			}

			if (date && tp_inst._parseTime(currDT, !inst.settings.timeOnly)) {
				date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
				date.setMicroseconds(tp_inst.microsec);

				// This is important if you are using the timezone option, javascript's Date
				// object will only return the timezone offset for the current locale, so we
				// adjust it accordingly.  If not using timezone option this won't matter..
				if (tp_inst.timezone != null) {
					// look out for DST if tz wasn't specified
					if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
						tp_inst.timezone = date.getTimezoneOffset() * -1;
					}
					date = $.timepicker.timezoneAdjust(date, tp_inst.timezone, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()));
				}
			}
			return date;
		}
		return this._base_getDateDatepicker(target, noDefault);
	};

	/*
 * override parseDate() because UI 1.8.14 throws an error about "Extra characters"
 * An option in datapicker to ignore extra format characters would be nicer.
 */
	$.datepicker._base_parseDate = $.datepicker.parseDate;
	$.datepicker.parseDate = function (format, value, settings) {
		var date;
		try {
			date = this._base_parseDate(format, value, settings);
		} catch (err) {
			// Hack!  The error message ends with a colon, a space, and
			// the "extra" characters.  We rely on that instead of
			// attempting to perfectly reproduce the parsing algorithm.
			if (err.indexOf(":") >= 0) {
				date = this._base_parseDate(format, value.substring(0, value.length - (err.length - err.indexOf(':') - 2)), settings);
				$.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
			} else {
				throw err;
			}
		}
		return date;
	};

	/*
 * override formatDate to set date with time to the input
 */
	$.datepicker._base_formatDate = $.datepicker._formatDate;
	$.datepicker._formatDate = function (inst, day, month, year) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			tp_inst._updateDateTime(inst);
			return tp_inst.$input.val();
		}
		return this._base_formatDate(inst);
	};

	/*
 * override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
 */
	$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
	$.datepicker._optionDatepicker = function (target, name, value) {
		var inst = this._getInst(target),
		    name_clone;
		if (!inst) {
			return null;
		}

		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var min = null,
			    max = null,
			    onselect = null,
			    overrides = tp_inst._defaults.evnts,
			    fns = {},
			    prop,
			    ret,
			    oldVal,
			    $target;
			if (typeof name === 'string') {
				// if min/max was set with the string
				if (name === 'minDate' || name === 'minDateTime') {
					min = value;
				} else if (name === 'maxDate' || name === 'maxDateTime') {
					max = value;
				} else if (name === 'onSelect') {
					onselect = value;
				} else if (overrides.hasOwnProperty(name)) {
					if (typeof value === 'undefined') {
						return overrides[name];
					}
					fns[name] = value;
					name_clone = {}; //empty results in exiting function after overrides updated
				}
			} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
				//if min/max was set with the JSON
				if (name.minDate) {
					min = name.minDate;
				} else if (name.minDateTime) {
					min = name.minDateTime;
				} else if (name.maxDate) {
					max = name.maxDate;
				} else if (name.maxDateTime) {
					max = name.maxDateTime;
				}
				for (prop in overrides) {
					if (overrides.hasOwnProperty(prop) && name[prop]) {
						fns[prop] = name[prop];
					}
				}
			}
			for (prop in fns) {
				if (fns.hasOwnProperty(prop)) {
					overrides[prop] = fns[prop];
					if (!name_clone) {
						name_clone = $.extend({}, name);
					}
					delete name_clone[prop];
				}
			}
			if (name_clone && isEmptyObject(name_clone)) {
				return;
			}
			if (min) {
				//if min was set
				if (min === 0) {
					min = new Date();
				} else {
					min = new Date(min);
				}
				tp_inst._defaults.minDate = min;
				tp_inst._defaults.minDateTime = min;
			} else if (max) {
				//if max was set
				if (max === 0) {
					max = new Date();
				} else {
					max = new Date(max);
				}
				tp_inst._defaults.maxDate = max;
				tp_inst._defaults.maxDateTime = max;
			} else if (onselect) {
				tp_inst._defaults.onSelect = onselect;
			}

			// Datepicker will override our date when we call _base_optionDatepicker when
			// calling minDate/maxDate, so we will first grab the value, call
			// _base_optionDatepicker, then set our value back.
			if (min || max) {
				$target = $(target);
				oldVal = $target.datetimepicker('getDate');
				ret = this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
				$target.datetimepicker('setDate', oldVal);
				return ret;
			}
		}
		if (value === undefined) {
			return this._base_optionDatepicker.call($.datepicker, target, name);
		}
		return this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
	};

	/*
 * jQuery isEmptyObject does not check hasOwnProperty - if someone has added to the object prototype,
 * it will return false for all objects
 */
	var isEmptyObject = function isEmptyObject(obj) {
		var prop;
		for (prop in obj) {
			if (obj.hasOwnProperty(prop)) {
				return false;
			}
		}
		return true;
	};

	/*
 * jQuery extend now ignores nulls!
 */
	var extendRemove = function extendRemove(target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] === null || props[name] === undefined) {
				target[name] = props[name];
			}
		}
		return target;
	};

	/*
 * Determine by the time format which units are supported
 * Returns an object of booleans for each unit
 */
	var detectSupport = function detectSupport(timeFormat) {
		var tf = timeFormat.replace(/'.*?'/g, '').toLowerCase(),
		    // removes literals
		isIn = function isIn(f, t) {
			// does the format contain the token?
			return f.indexOf(t) !== -1 ? true : false;
		};
		return {
			hour: isIn(tf, 'h'),
			minute: isIn(tf, 'm'),
			second: isIn(tf, 's'),
			millisec: isIn(tf, 'l'),
			microsec: isIn(tf, 'c'),
			timezone: isIn(tf, 'z'),
			ampm: isIn(tf, 't') && isIn(timeFormat, 'h'),
			iso8601: isIn(timeFormat, 'Z')
		};
	};

	/*
 * Converts 24 hour format into 12 hour
 * Returns 12 hour without leading 0
 */
	var convert24to12 = function convert24to12(hour) {
		hour %= 12;

		if (hour === 0) {
			hour = 12;
		}

		return String(hour);
	};

	var computeEffectiveSetting = function computeEffectiveSetting(settings, property) {
		return settings && settings[property] ? settings[property] : $.timepicker._defaults[property];
	};

	/*
 * Splits datetime string into date and time substrings.
 * Throws exception when date can't be parsed
 * Returns {dateString: dateString, timeString: timeString}
 */
	var splitDateTime = function splitDateTime(dateTimeString, timeSettings) {
		// The idea is to get the number separator occurrences in datetime and the time format requested (since time has
		// fewer unknowns, mostly numbers and am/pm). We will use the time pattern to split.
		var separator = computeEffectiveSetting(timeSettings, 'separator'),
		    format = computeEffectiveSetting(timeSettings, 'timeFormat'),
		    timeParts = format.split(separator),
		    // how many occurrences of separator may be in our format?
		timePartsLen = timeParts.length,
		    allParts = dateTimeString.split(separator),
		    allPartsLen = allParts.length;

		if (allPartsLen > 1) {
			return {
				dateString: allParts.splice(0, allPartsLen - timePartsLen).join(separator),
				timeString: allParts.splice(0, timePartsLen).join(separator)
			};
		}

		return {
			dateString: dateTimeString,
			timeString: ''
		};
	};

	/*
 * Internal function to parse datetime interval
 * Returns: {date: Date, timeObj: Object}, where
 *   date - parsed date without time (type Date)
 *   timeObj = {hour: , minute: , second: , millisec: , microsec: } - parsed time. Optional
 */
	var parseDateTimeInternal = function parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var date, parts, parsedTime;

		parts = splitDateTime(dateTimeString, timeSettings);
		date = $.datepicker._base_parseDate(dateFormat, parts.dateString, dateSettings);

		if (parts.timeString === '') {
			return {
				date: date
			};
		}

		parsedTime = $.datepicker.parseTime(timeFormat, parts.timeString, timeSettings);

		if (!parsedTime) {
			throw 'Wrong time format';
		}

		return {
			date: date,
			timeObj: parsedTime
		};
	};

	/*
 * Internal function to set timezone_select to the local timezone
 */
	var selectLocalTimezone = function selectLocalTimezone(tp_inst, date) {
		if (tp_inst && tp_inst.timezone_select) {
			var now = date || new Date();
			tp_inst.timezone_select.val(-now.getTimezoneOffset());
		}
	};

	/*
 * Create a Singleton Instance
 */
	$.timepicker = new Timepicker();

	/**
  * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
  * @param {number} tzMinutes if not a number, less than -720 (-1200), or greater than 840 (+1400) this value is returned
  * @param {boolean} iso8601 if true formats in accordance to iso8601 "+12:45"
  * @return {string}
  */
	$.timepicker.timezoneOffsetString = function (tzMinutes, iso8601) {
		if (isNaN(tzMinutes) || tzMinutes > 840 || tzMinutes < -720) {
			return tzMinutes;
		}

		var off = tzMinutes,
		    minutes = off % 60,
		    hours = (off - minutes) / 60,
		    iso = iso8601 ? ':' : '',
		    tz = (off >= 0 ? '+' : '-') + ('0' + Math.abs(hours)).slice(-2) + iso + ('0' + Math.abs(minutes)).slice(-2);

		if (tz === '+00:00') {
			return 'Z';
		}
		return tz;
	};

	/**
  * Get the number in minutes that represents a timezone string
  * @param  {string} tzString formatted like "+0500", "-1245", "Z"
  * @return {number} the offset minutes or the original string if it doesn't match expectations
  */
	$.timepicker.timezoneOffsetNumber = function (tzString) {
		var normalized = tzString.toString().replace(':', ''); // excuse any iso8601, end up with "+1245"

		if (normalized.toUpperCase() === 'Z') {
			// if iso8601 with Z, its 0 minute offset
			return 0;
		}

		if (!/^(\-|\+)\d{4}$/.test(normalized)) {
			// possibly a user defined tz, so just give it back
			return parseInt(tzString, 10);
		}

		return (normalized.substr(0, 1) === '-' ? -1 : 1) * ( // plus or minus
		parseInt(normalized.substr(1, 2), 10) * 60 + // hours (converted to minutes)
		parseInt(normalized.substr(3, 2), 10)); // minutes
	};

	/**
  * No way to set timezone in js Date, so we must adjust the minutes to compensate. (think setDate, getDate)
  * @param  {Date} date
  * @param  {string} fromTimezone formatted like "+0500", "-1245"
  * @param  {string} toTimezone formatted like "+0500", "-1245"
  * @return {Date}
  */
	$.timepicker.timezoneAdjust = function (date, fromTimezone, toTimezone) {
		var fromTz = $.timepicker.timezoneOffsetNumber(fromTimezone);
		var toTz = $.timepicker.timezoneOffsetNumber(toTimezone);
		if (!isNaN(toTz)) {
			date.setMinutes(date.getMinutes() + -fromTz - -toTz);
		}
		return date;
	};

	/**
  * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * n.b. The input value must be correctly formatted (reformatting is not supported)
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the timepicker() call
  * @return {jQuery}
  */
	$.timepicker.timeRange = function (startTime, endTime, options) {
		return $.timepicker.handleRange('timepicker', startTime, endTime, options);
	};

	/**
  * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @param  {string} method Can be used to specify the type of picker to be added
  * @return {jQuery}
  */
	$.timepicker.datetimeRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datetimepicker', startTime, endTime, options);
	};

	/**
  * Calls `datepicker` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @return {jQuery}
  */
	$.timepicker.dateRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datepicker', startTime, endTime, options);
	};

	/**
  * Calls `method` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {string} method Can be used to specify the type of picker to be added
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @return {jQuery}
  */
	$.timepicker.handleRange = function (method, startTime, endTime, options) {
		options = $.extend({}, {
			minInterval: 0, // min allowed interval in milliseconds
			maxInterval: 0, // max allowed interval in milliseconds
			start: {}, // options for start picker
			end: {} // options for end picker
		}, options);

		// for the mean time this fixes an issue with calling getDate with timepicker()
		var timeOnly = false;
		if (method === 'timepicker') {
			timeOnly = true;
			method = 'datetimepicker';
		}

		function checkDates(changed, other) {
			var startdt = startTime[method]('getDate'),
			    enddt = endTime[method]('getDate'),
			    changeddt = changed[method]('getDate');

			if (startdt !== null) {
				var minDate = new Date(startdt.getTime()),
				    maxDate = new Date(startdt.getTime());

				minDate.setMilliseconds(minDate.getMilliseconds() + options.minInterval);
				maxDate.setMilliseconds(maxDate.getMilliseconds() + options.maxInterval);

				if (options.minInterval > 0 && minDate > enddt) {
					// minInterval check
					endTime[method]('setDate', minDate);
				} else if (options.maxInterval > 0 && maxDate < enddt) {
					// max interval check
					endTime[method]('setDate', maxDate);
				} else if (startdt > enddt) {
					other[method]('setDate', changeddt);
				}
			}
		}

		function selected(changed, other, option) {
			if (!changed.val()) {
				return;
			}
			var date = changed[method].call(changed, 'getDate');
			if (date !== null && options.minInterval > 0) {
				if (option === 'minDate') {
					date.setMilliseconds(date.getMilliseconds() + options.minInterval);
				}
				if (option === 'maxDate') {
					date.setMilliseconds(date.getMilliseconds() - options.minInterval);
				}
			}

			if (date.getTime) {
				other[method].call(other, 'option', option, date);
			}
		}

		$.fn[method].call(startTime, $.extend({
			timeOnly: timeOnly,
			onClose: function onClose(dateText, inst) {
				checkDates($(this), endTime);
			},
			onSelect: function onSelect(selectedDateTime) {
				selected($(this), endTime, 'minDate');
			}
		}, options, options.start));
		$.fn[method].call(endTime, $.extend({
			timeOnly: timeOnly,
			onClose: function onClose(dateText, inst) {
				checkDates($(this), startTime);
			},
			onSelect: function onSelect(selectedDateTime) {
				selected($(this), startTime, 'maxDate');
			}
		}, options, options.end));

		checkDates(startTime, endTime);

		selected(startTime, endTime, 'minDate');
		selected(endTime, startTime, 'maxDate');

		return $([startTime.get(0), endTime.get(0)]);
	};

	/**
  * Log error or data to the console during error or debugging
  * @param  {Object} err pass any type object to log to the console during error or debugging
  * @return {void}
  */
	$.timepicker.log = function () {
		// Older IE (9, maybe 10) throw error on accessing `window.console.log.apply`, so check first.
		if (window.console && window.console.log && window.console.log.apply) {
			window.console.log.apply(window.console, Array.prototype.slice.call(arguments));
		}
	};

	/*
  * Add util object to allow access to private methods for testability.
  */
	$.timepicker._util = {
		_extendRemove: extendRemove,
		_isEmptyObject: isEmptyObject,
		_convert24to12: convert24to12,
		_detectSupport: detectSupport,
		_selectLocalTimezone: selectLocalTimezone,
		_computeEffectiveSetting: computeEffectiveSetting,
		_splitDateTime: splitDateTime,
		_parseDateTimeInternal: parseDateTimeInternal
	};

	/*
 * Microsecond support
 */
	if (!Date.prototype.getMicroseconds) {
		Date.prototype.microseconds = 0;
		Date.prototype.getMicroseconds = function () {
			return this.microseconds;
		};
		Date.prototype.setMicroseconds = function (m) {
			this.setMilliseconds(this.getMilliseconds() + Math.floor(m / 1000));
			this.microseconds = m % 1000;
			return this;
		};
	}

	/*
 * Keep up with the version
 */
	$.timepicker.version = "1.6.3";
});

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = jQuery.ui;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Number Field functionality.
 *
 * @since 1.4.0
 */
var FieldNumber = function (_Field) {
    _inherits(FieldNumber, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldNumber($field) {
        _classCallCheck(this, FieldNumber);

        var _this = _possibleConstructorReturn(this, (FieldNumber.__proto__ || Object.getPrototypeOf(FieldNumber)).call(this, $field, 'number'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the Number field.
     *
     * @since 1.4.0
     */


    _createClass(FieldNumber, [{
        key: 'initField',
        value: function initField() {

            this.$ui = {
                container: this.$field,
                input: this.$field.find('.fieldhelpers-field-input'),
                increase: this.$field.find('[data-number-increase]'),
                decrease: this.$field.find('[data-number-decrease]')
            };

            this.intervals = {
                increase: {
                    normal: parseInt(this.options.increaseInterval),
                    alt: parseInt(this.options.altIncreaseInterval)
                },
                decrease: {
                    normal: parseInt(this.options.decreaseInterval),
                    alt: parseInt(this.options.altDecreaseInterval)
                }
            };

            var constrainMax = this.options.max;
            var constrainMin = this.options.min;

            this.constraints = {
                max: constrainMax !== 'none' ? parseInt(constrainMax) : false,
                min: constrainMin !== 'none' ? parseInt(constrainMin) : false
            };

            this.shiftKeyUtility();
            this.setupHandlers();

            var initialValue = this.$ui.input.val();
            this.value = !initialValue ? 0 : parseInt(initialValue);

            // Initializes the field
            this.validateInput();
        }

        /**
         * Helps determine shift key press status.
         *
         * @since 1.4.0
         */

    }, {
        key: 'shiftKeyUtility',
        value: function shiftKeyUtility() {
            var _this2 = this;

            this.shiftKeyDown = false;

            jQuery(document).on('keydown', function (e) {

                if (e.which === 16) {

                    _this2.shiftKeyDown = true;
                }
            });

            jQuery(document).on('keyup', function (e) {

                if (e.which === 16) {

                    _this2.shiftKeyDown = false;
                }
            });
        }

        /**
         * Sets up the class handlers.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setupHandlers',
        value: function setupHandlers() {
            var _this3 = this;

            this.$ui.increase.click(function (e) {

                _this3.increaseNumber(e);
            });

            this.$ui.decrease.click(function (e) {

                _this3.decreaseNumber(e);
            });

            this.$ui.input.change(function (e) {

                _this3.inputExternalChange(e);
            });
        }

        /**
         * Increases the input number.
         *
         * @since 1.4.0
         */

    }, {
        key: 'increaseNumber',
        value: function increaseNumber() {

            var amount = this.shiftKeyDown ? this.intervals.increase.alt : this.intervals.increase.normal;
            var newNumber = this.value + amount;

            this.$ui.input.val(newNumber);
            this.$ui.input.trigger('change');
        }

        /**
         * Decreases the input number.
         *
         * @since 1.4.0
         */

    }, {
        key: 'decreaseNumber',
        value: function decreaseNumber() {

            var amount = this.shiftKeyDown ? this.intervals.decrease.alt : this.intervals.decrease.normal;
            var newNumber = this.value - amount;

            this.$ui.input.val(newNumber);
            this.$ui.input.trigger('change');
        }

        /**
         * Fires on the input change. Typically from user typing or other scripts modifying.
         *
         * @since 1.4.0
         */

    }, {
        key: 'inputExternalChange',
        value: function inputExternalChange() {

            this.validateInput();
        }

        /**
         * Runs number through constrains.
         *
         * @param {int} number
         *
         * @return {Object}
         */

    }, {
        key: 'constrainNumber',
        value: function constrainNumber(number) {

            var status = 'unmodified';

            if (this.constraints.max !== false && number > this.constraints.max) {

                status = 'max';
                number = this.constraints.max;
            } else if (this.constraints.min !== false && number < this.constraints.min) {

                status = 'min';
                number = this.constraints.min;
            }

            return {
                status: status,
                number: number
            };
        }

        /**
         * Runs input value through constraints to ensure it is accurate.
         *
         * @since 1.4.0
         */

    }, {
        key: 'validateInput',
        value: function validateInput() {

            var currentValue = this.$ui.input.val();

            // Constrain to numbers
            var matches = currentValue.match(/^-?[0-9]\d*(\.\d+)?$/);
            currentValue = matches && parseInt(matches[0]) || 0;

            var constraints = this.constrainNumber(currentValue);

            switch (constraints.status) {

                case 'max':

                    this.toggleDecreaseDisabledUI(true);
                    this.toggleIncreaseDisabledUI(false);
                    break;

                case 'min':

                    this.toggleIncreaseDisabledUI(true);
                    this.toggleDecreaseDisabledUI(false);
                    break;

                default:

                    this.toggleIncreaseDisabledUI(true);
                    this.toggleDecreaseDisabledUI(true);

            }

            this.value = constraints.number;
            this.$ui.input.val(this.value);

            if (currentValue !== this.value) {

                this.$ui.input.trigger('change');
            }
        }

        /**
         * Disables/Enables the increase button.
         *
         * @since 1.4.0
         *
         * @param {bool} enable True to set to enabled, false to set to disabled
         */

    }, {
        key: 'toggleIncreaseDisabledUI',
        value: function toggleIncreaseDisabledUI(enable) {

            this.$ui.increase.prop('disabled', !enable);
        }

        /**
         * Disables/Enables the decrease button.
         *
         * @since 1.4.0
         *
         * @param {bool} enable True to set to enabled, false to set to disabled
         */

    }, {
        key: 'toggleDecreaseDisabledUI',
        value: function toggleDecreaseDisabledUI(enable) {

            this.$ui.decrease.prop('disabled', !enable);
        }
    }]);

    return FieldNumber;
}(_field2.default);

/**
 * Finds and initializes all Number fields.
 *
 * @since 1.4.0
 */


var FieldNumberInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldNumberInitialize($root) {
        _classCallCheck(this, FieldNumberInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-number]');

        if ($fields.length) {

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldNumberInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldNumber($field)
            });
        }
    }]);

    return FieldNumberInitialize;
}();

exports.default = FieldNumberInitialize;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Color Picker Field functionality.
 *
 * @since 1.4.0
 */
var FieldColorPicker = function (_Field) {
    _inherits(FieldColorPicker, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldColorPicker($field) {
        _classCallCheck(this, FieldColorPicker);

        var _this = _possibleConstructorReturn(this, (FieldColorPicker.__proto__ || Object.getPrototypeOf(FieldColorPicker)).call(this, $field, 'colorpicker'));

        _this.initializeColorpicker();
        return _this;
    }

    /**
     * Initializes the Color Picker.
     *
     * @since 1.4.0
     */


    _createClass(FieldColorPicker, [{
        key: 'initializeColorpicker',
        value: function initializeColorpicker() {

            this.$field.wpColorPicker(this.options.colorpickerOptions);
        }

        /**
         * Cleans up after a repeater add/init.
         *
         * @since 1.4.0
         */

    }, {
        key: 'fieldCleanup',
        value: function fieldCleanup() {

            this.$wrapper.find('[data-fieldhelpers-field-colorpicker]').appendTo(this.$wrapper.find('.fieldhelpers-field-content'));

            this.$wrapper.find('.wp-picker-container').remove();
        }
    }]);

    return FieldColorPicker;
}(_field2.default);

/**
 * Finds and initializes all Color Picker fields.
 *
 * @since 1.4.0
 */


var FieldColorPickerInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldColorPickerInitialize($root) {
        _classCallCheck(this, FieldColorPickerInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-colorpicker]');

        if ($fields.length) {

            if (!jQuery.isFunction(jQuery.fn.wpColorPicker)) {

                console.error('Field Helpers Error: Trying to initialize Color Picker field but "wp-color-picker" is ' + 'not enqueued.');
                return;
            }

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldColorPickerInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldColorPicker($field)
            });
        }
    }]);

    return FieldColorPickerInitialize;
}();

exports.default = FieldColorPickerInitialize;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Date Picker Field functionality.
 *
 * Also includes Date/Time Picker and Time Picker.
 *
 * @since 1.4.0
 */
var FieldDatePicker = function (_Field) {
    _inherits(FieldDatePicker, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldDatePicker($field) {
        _classCallCheck(this, FieldDatePicker);

        var _this = _possibleConstructorReturn(this, (FieldDatePicker.__proto__ || Object.getPrototypeOf(FieldDatePicker)).call(this, $field, 'datepicker'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the Date Picker.
     *
     * @since 1.4.0
     */


    _createClass(FieldDatePicker, [{
        key: 'initField',
        value: function initField() {
            var _this2 = this;

            this.$hiddenField = this.$field.next('input[type="hidden"]');

            var option_functions = ['beforeShow', 'beforeShowDay', 'calculateWeek', 'onChangeMonthYear', 'onClose', 'onSelect'];

            // Function support
            jQuery.each(this.options.datepickerOptions, function (name, value) {

                if (option_functions.indexOf(name) !== -1 && !jQuery.isFunction(_this2.options.datepickerOptions[name]) && jQuery.isFunction(window[value])) {

                    _this2.options.datepickerOptions[name] = window[value];
                }
            });

            this.options.datepickerOptions.altField = this.$hiddenField;

            this.$field.datepicker(this.options.datepickerOptions);
        }

        /**
         * Cleans up after a repeater add/init.
         *
         * @since 1.4.0
         */

    }, {
        key: 'fieldCleanup',
        value: function fieldCleanup() {

            this.$field.removeClass('hasDatepicker').removeAttr('id');
        }
    }]);

    return FieldDatePicker;
}(_field2.default);

/**
 * Finds and initializes all Date Picker fields.
 *
 * @since 1.4.0
 */


var FieldDatePickerInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldDatePickerInitialize($root) {
        _classCallCheck(this, FieldDatePickerInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-datepicker]');

        if ($fields.length) {

            if (!jQuery.isFunction(jQuery.fn.datepicker)) {

                console.error('Field Helpers Error: Trying to initialize Date Picker field but "jquery-ui-datepicker" ' + 'is not enqueued.');
                return;
            }

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldDatePickerInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldDatePicker($field)
            });
        }
    }]);

    return FieldDatePickerInitialize;
}();

exports.default = FieldDatePickerInitialize;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Time Picker Field functionality.
 *
 * Also includes Date/Time Picker and Time Picker.
 *
 * @since 1.4.0
 */
var FieldTimePicker = function (_Field) {
    _inherits(FieldTimePicker, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldTimePicker($field) {
        _classCallCheck(this, FieldTimePicker);

        var _this = _possibleConstructorReturn(this, (FieldTimePicker.__proto__ || Object.getPrototypeOf(FieldTimePicker)).call(this, $field, 'timepicker'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the Time Picker.
     *
     * @since 1.4.0
     */


    _createClass(FieldTimePicker, [{
        key: 'initField',
        value: function initField() {
            var _this2 = this;

            this.$hiddenField = this.$field.next('input[type="hidden"]');

            var option_functions = ['beforeShow', 'beforeShowDay', 'calculateWeek', 'onChangeMonthYear', 'onClose', 'onSelect'];
            var options = {};

            if (RBM_FieldHelpers['datepicker_args_' + name]) {

                options = RBM_FieldHelpers['datepicker_args_' + name];
            }

            // Function support
            jQuery.each(this.options.timepickerOptions, function (name, value) {

                if (option_functions.indexOf(name) !== -1 && !jQuery.isFunction(_this2.options.timepickerOptions[name]) && jQuery.isFunction(window[value])) {

                    _this2.options.timepickerOptions[name] = window[value];
                }
            });

            options.altField = this.$hiddenField;

            this.$field.timepicker(this.options.timepickerOptions);
        }

        /**
         * Cleans up after a repeater add/init.
         *
         * @since 1.4.0
         */

    }, {
        key: 'fieldCleanup',
        value: function fieldCleanup() {

            this.$field.removeClass('hasDatepicker').removeAttr('id');
        }
    }]);

    return FieldTimePicker;
}(_field2.default);

/**
 * Finds and initializes all Time Picker fields.
 *
 * @since 1.4.0
 */


var FieldTimePickerInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldTimePickerInitialize($root) {
        _classCallCheck(this, FieldTimePickerInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-timepicker]');

        if ($fields.length) {

            if (!jQuery.isFunction(jQuery.fn.timepicker)) {

                console.error('Field Helpers Error: Trying to initialize Time Picker field but ' + '"jquery-ui-datetimepicker" is not enqueued.');
                return;
            }

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldTimePickerInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldTimePicker($field)
            });
        }
    }]);

    return FieldTimePickerInitialize;
}();

exports.default = FieldTimePickerInitialize;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Date Time Picker Field functionality.
 *
 * Also includes Date/Time Picker and Time Picker.
 *
 * @since 1.4.0
 */
var FieldDateTimePicker = function (_Field) {
    _inherits(FieldDateTimePicker, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldDateTimePicker($field) {
        _classCallCheck(this, FieldDateTimePicker);

        var _this = _possibleConstructorReturn(this, (FieldDateTimePicker.__proto__ || Object.getPrototypeOf(FieldDateTimePicker)).call(this, $field, 'datetimepicker'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the Date Time Picker.
     *
     * @since 1.4.0
     */


    _createClass(FieldDateTimePicker, [{
        key: 'initField',
        value: function initField() {
            var _this2 = this;

            this.$hiddenField = this.$field.next('input[type="hidden"]');

            var option_functions = ['beforeShow', 'beforeShowDay', 'calculateWeek', 'onChangeMonthYear', 'onClose', 'onSelect'];

            // Function support
            jQuery.each(this.options.datetimepickerOptions, function (name, value) {

                if (option_functions.indexOf(name) !== -1 && !jQuery.isFunction(_this2.options.datetimepickerOptions[name]) && jQuery.isFunction(window[value])) {

                    _this2.options.datetimepickerOptions[name] = window[value];
                }
            });

            this.options.datetimepickerOptions.altField = this.$hiddenField;

            this.$field.datetimepicker(this.options.datetimepickerOptions);
        }

        /**
         * Cleans up after a repeater add/init.
         *
         * @since 1.4.0
         */

    }, {
        key: 'fieldCleanup',
        value: function fieldCleanup() {

            this.$field.removeClass('hasDatepicker').removeAttr('id');
        }
    }]);

    return FieldDateTimePicker;
}(_field2.default);

/**
 * Finds and initializes all Date Time Picker fields.
 *
 * @since 1.4.0
 */


var FieldDateTimePickerInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldDateTimePickerInitialize($root) {
        _classCallCheck(this, FieldDateTimePickerInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-datetimepicker]');

        if ($fields.length) {

            if (!jQuery.isFunction(jQuery.fn.datetimepicker)) {

                console.error('Field Helpers Error: Trying to initialize Date Time Picker field but ' + '"rbm-fh-jquery-ui-datetimepicker" is not enqueued.');
                return;
            }

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldDateTimePickerInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldDateTimePicker($field)
            });
        }
    }]);

    return FieldDateTimePickerInitialize;
}();

exports.default = FieldDateTimePickerInitialize;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Table Field functionality.
 *
 * @since 1.4.0
 */
var FieldTable = function (_Field) {
    _inherits(FieldTable, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldTable($field) {
        _classCallCheck(this, FieldTable);

        var _this = _possibleConstructorReturn(this, (FieldTable.__proto__ || Object.getPrototypeOf(FieldTable)).call(this, $field, 'table'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the Table field.
     *
     * @since 1.4.0
     */


    _createClass(FieldTable, [{
        key: 'initField',
        value: function initField() {

            this.$ui = {
                actions: this.$field.find('.fieldhelpers-field-table-actions'),
                loading: this.$field.find('.fieldhelpers-field-table-loading'),
                table: this.$field.find('table'),
                thead: this.$field.find('thead'),
                tbody: this.$field.find('tbody'),
                addRow: this.$field.find('[data-table-create-row]'),
                addColumn: this.$field.find('[data-table-create-column]')
            };

            this.l10n = RBM_FieldHelpers.l10n['field_table'] || {};

            this.name = this.$field.attr('data-table-name');

            var data = JSON.parse(this.$ui.table.attr('data-table-data'));

            this.data = {};
            this.data.head = data.head || [];
            this.data.body = data.body || [];

            this.setupHandlers();

            // Initial build
            this.buildTable();

            // Show initially
            this.$ui.table.show();
            this.$ui.actions.show();
            this.$ui.loading.hide();
        }

        /**
         * Sets up the class handlers.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setupHandlers',
        value: function setupHandlers() {
            var _this2 = this;

            var api = this;

            this.$ui.addRow.click(function (e) {

                e.preventDefault();
                _this2.addRow();
            });

            this.$ui.addColumn.click(function (e) {

                e.preventDefault();
                _this2.addColumn();
            });

            this.$ui.table.on('click', '[data-delete-row]', function (e) {

                var index = jQuery(this).closest('tr').index();

                api.deleteRow(index);
            });

            this.$ui.table.on('click', '[data-delete-column]', function (e) {

                var index = jQuery(this).closest('td').index();

                api.deleteColumn(index);
            });

            this.$ui.table.on('change', 'input[type="text"]', function (e) {

                _this2.updateTableData();
            });
        }

        /**
         * Gathers all data from the table.
         */

    }, {
        key: 'updateTableData',
        value: function updateTableData() {

            var api = this;

            // Head
            var $headCells = this.$ui.table.find('thead th');
            var dataHead = [];
            var currentCell = 0;

            $headCells.each(function () {

                var $input = jQuery(this).find('input[name="' + api.name + '[head][' + currentCell + ']"]');

                if (!$input.length) {

                    console.error('Field Helpers Error: Table head data corrupted.');
                    return false;
                }

                dataHead.push($input.val());

                currentCell++;
            });

            this.data.head = dataHead;

            // Body
            var $bodyRows = this.$ui.table.find('tbody tr');
            var dataBody = [];
            var currentRow = 0;

            $bodyRows.each(function () {

                // Skip delete row
                if (jQuery(this).hasClass('fieldhelpers-field-table-delete-columns')) {

                    return true;
                }

                var rowData = [];
                var $cells = jQuery(this).find('td');
                var currentCell = 0;

                $cells.each(function () {

                    // Skip delete cell
                    if (jQuery(this).hasClass('fieldhelpers-field-table-delete-row')) {

                        return true;
                    }

                    var $input = jQuery(this).find('input[name="' + api.name + '[body][' + currentRow + '][' + currentCell + ']"]');

                    if (!$input.length) {

                        console.error('Field Helpers Error: Table body data corrupted.');
                        return false;
                    }

                    rowData.push($input.val());

                    currentCell++;
                });

                dataBody.push(rowData);

                currentRow++;
            });

            this.data.body = dataBody;
        }

        /**
         * Adds a row to the table.
         *
         * @since 1.4.0
         */

    }, {
        key: 'addRow',
        value: function addRow() {

            if (!this.data.head.length) {

                this.data.head.push('');
            }

            if (!this.data.body.length) {

                // Push 1 empty row with 1 empty cell
                this.data.body.push(['']);
            } else {

                var columns = this.data.body[0].length;
                var row = [];

                for (var i = 0; i < columns; i++) {
                    row.push('');
                }

                this.data.body.push(row);
            }

            this.buildTable();
        }

        /**
         * Adds a column to the table.
         *
         * @since 1.4.0
         */

    }, {
        key: 'addColumn',
        value: function addColumn() {

            if (!this.data.body.length) {

                // Push 1 empty row with 1 empty cell
                this.data.head.push(['']);
                this.data.body.push(['']);
            } else {

                this.data.head.push('');

                this.data.body.map(function (row) {
                    row.push('');
                });
            }

            this.buildTable();
        }

        /**
         * Deletes a row from the table.
         *
         * @since 1.4.0
         *
         * @param {int} index Index of row to delete.
         */

    }, {
        key: 'deleteRow',
        value: function deleteRow(index) {

            // Decrease to compensate for "delete row" at top
            index--;

            if (this.data.body.length === 1) {

                this.data.head = [];
                this.data.body = [];
            } else {

                this.data.body.splice(index, 1);
            }

            this.buildTable();
        }

        /**
         * Deletes a column from the table.
         *
         * @since 1.4.0
         *
         * @param {int} index Index of column to delete.
         */

    }, {
        key: 'deleteColumn',
        value: function deleteColumn(index) {

            if (this.data.body[0].length === 1) {

                this.data.head = [];
                this.data.body = [];
            } else {

                this.data.head.splice(index, 1);

                this.data.body.map(function (row) {
                    return row.splice(index, 1);
                });
            }

            this.buildTable();
        }

        /**
         * Builds the table based on the table data.
         *
         * @since 1.4.0
         */

    }, {
        key: 'buildTable',
        value: function buildTable() {
            var _this3 = this;

            this.$ui.thead.html('');
            this.$ui.tbody.html('');

            if (this.data.head.length) {

                var $row = jQuery('<tr />');

                this.data.head.map(function (cell, cell_i) {

                    var $cell = jQuery('<th />');

                    $cell.append('<input type="text" name="' + _this3.name + '[head][' + cell_i + ']" />');
                    $cell.find('input[type="text"]').val(cell);

                    $row.append($cell);
                });

                this.$ui.thead.append($row);
            }

            if (this.data.body.length) {

                var $deleteRow = jQuery('<tr class="fieldhelpers-field-table-delete-columns"></tr>');

                for (var i = 0; i < this.data.body[0].length; i++) {

                    $deleteRow.append('<td>' + ('<button type="button" data-delete-column aria-label="' + this.l10n['delete_column'] + '">') + '<span class="dashicons dashicons-no" />' + '</button>' + '</td>');
                }

                this.$ui.tbody.append($deleteRow);

                this.data.body.map(function (row, row_i) {

                    var $row = jQuery('<tr/>');

                    row.map(function (cell, cell_i) {

                        var $cell = jQuery('<td/>');

                        $cell.append('<input type="text" name="' + _this3.name + '[body][' + row_i + '][' + cell_i + ']" />');
                        $cell.find('input[type="text"]').val(cell);

                        $row.append($cell);
                    });

                    $row.append('<td class="fieldhelpers-field-table-delete-row">' + ('<button type="button" data-delete-row aria-label="' + _this3.l10n['delete_row'] + '">') + '<span class="dashicons dashicons-no" />' + '</button>' + '</td>');

                    _this3.$ui.tbody.append($row);
                });
            }
        }
    }]);

    return FieldTable;
}(_field2.default);

/**
 * Finds and initializes all Table fields.
 *
 * @since 1.4.0
 */


var FieldTableInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldTableInitialize($root) {
        _classCallCheck(this, FieldTableInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-table]');

        if ($fields.length) {

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldTableInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldTable($field)
            });
        }
    }]);

    return FieldTableInitialize;
}();

exports.default = FieldTableInitialize;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Media Field functionality.
 *
 * @since 1.4.0
 */
var FieldMedia = function (_Field) {
    _inherits(FieldMedia, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldMedia($field) {
        _classCallCheck(this, FieldMedia);

        var _this = _possibleConstructorReturn(this, (FieldMedia.__proto__ || Object.getPrototypeOf(FieldMedia)).call(this, $field, 'media'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the Media field.
     *
     * @since 1.4.0
     */


    _createClass(FieldMedia, [{
        key: 'initField',
        value: function initField() {

            this.$ui = {
                input: this.$field.find('[data-media-input]'),
                addButton: this.$field.find('[data-add-media]'),
                imagePreview: this.$field.find('[data-image-preview]'),
                mediaPreview: this.$field.find('[data-media-preview]'),
                removeButton: this.$field.find('[data-remove-media]')
            };

            this.mediaFrame = wp.media.frames.meta_image_frame = wp.media({
                title: this.options.l10n['window_title']
            });

            this.placeholder = this.options.placeholder;
            this.type = this.options.type;

            this.imageProperties = {
                previewSize: this.options.previewSize
            };

            this.setupHandlers();
        }

        /**
         * Sets up the class handlers.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setupHandlers',
        value: function setupHandlers() {
            var _this2 = this;

            this.$ui.addButton.click(function (e) {

                e.preventDefault();
                _this2.addMedia();
            });

            this.$ui.removeButton.click(function (e) {

                e.preventDefault();
                _this2.removeMedia();
            });

            this.mediaFrame.on('select', function (e) {

                _this2.selectMedia();
            });
        }

        /**
         * Opens the media frame to add media.
         *
         * @since 1.4.0
         */

    }, {
        key: 'addMedia',
        value: function addMedia() {

            this.mediaFrame.open();
        }

        /**
         * Removes the currently selected media.
         *
         * @since 1.4.0
         */

    }, {
        key: 'removeMedia',
        value: function removeMedia() {

            this.$ui.addButton.show();
            this.$ui.removeButton.hide();
            this.$ui.input.val('');

            // Reset preview
            switch (this.type) {

                case 'image':

                    this.$ui.imagePreview.attr('src', this.placeholder || '');

                    break;

                default:

                    this.$ui.mediaPreview.html(this.placeholder || '&nbsp;');
            }
        }

        /**
         * Fires on selecting a piece of media.
         *
         * @since 1.4.0
         */

    }, {
        key: 'selectMedia',
        value: function selectMedia() {

            var mediaAttachment = this.mediaFrame.state().get('selection').first().toJSON();

            this.$ui.input.val(mediaAttachment.id);

            this.$ui.addButton.hide();
            this.$ui.removeButton.show();

            // Preview
            switch (this.type) {

                case 'image':

                    var previewUrl = mediaAttachment.url;

                    if (mediaAttachment.sizes[this.imageProperties.previewSize]) {

                        previewUrl = mediaAttachment.sizes[this.imageProperties.previewSize].url;
                    }

                    this.$ui.imagePreview.attr('src', previewUrl);
                    break;

                default:

                    this.$ui.mediaPreview.html(mediaAttachment.url);
            }
        }
    }]);

    return FieldMedia;
}(_field2.default);

/**
 * Finds and initializes all Media fields.
 *
 * @since 1.4.0
 */


var FieldMediaInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldMediaInitialize($root) {
        _classCallCheck(this, FieldMediaInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-media]');

        if ($fields.length) {

            if (!wp.media) {

                console.error('Field Helpers Error: Trying to initialize Media field but media is not enqueued.');
                return;
            }

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldMediaInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldMedia($field)
            });
        }
    }]);

    return FieldMediaInitialize;
}();

exports.default = FieldMediaInitialize;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * List Field functionality.
 *
 * @since 1.4.0
 */
var FieldList = function (_Field) {
    _inherits(FieldList, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldList($field) {
        _classCallCheck(this, FieldList);

        var _this = _possibleConstructorReturn(this, (FieldList.__proto__ || Object.getPrototypeOf(FieldList)).call(this, $field, 'list'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the list.
     *
     * @since 1.4.0
     */


    _createClass(FieldList, [{
        key: 'initField',
        value: function initField() {

            this.$field.sortable(this.options);
        }
    }]);

    return FieldList;
}(_field2.default);

/**
 * Finds and initializes all List fields.
 *
 * @since 1.4.0
 */


var FieldListInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldListInitialize($root) {
        _classCallCheck(this, FieldListInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-list]');

        if ($fields.length) {

            if (!jQuery.isFunction(jQuery.fn.sortable)) {

                console.error('Field Helpers Error: Trying to initialize List field but "jquery-ui-sortable" ' + 'is not enqueued.');
                return;
            }

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldListInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldList($field)
            });
        }
    }]);

    return FieldListInitialize;
}();

exports.default = FieldListInitialize;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

var _fieldsInit = __webpack_require__(1);

var _fieldsInit2 = _interopRequireDefault(_fieldsInit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Repeater Field functionality.
 *
 * @since 1.4.0
 */
var FieldRepeater = function (_Field) {
    _inherits(FieldRepeater, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldRepeater($field) {
        _classCallCheck(this, FieldRepeater);

        var _this = _possibleConstructorReturn(this, (FieldRepeater.__proto__ || Object.getPrototypeOf(FieldRepeater)).call(this, $field, 'repeater'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the Repeater.
     *
     * @since 1.4.0
     */


    _createClass(FieldRepeater, [{
        key: 'initField',
        value: function initField() {
            var _this2 = this;

            this.$repeaterList = this.$field.find('.fieldhelpers-field-repeater-list');

            var api = this;

            this.repeater = this.$field.repeater({
                show: function show() {
                    api.repeaterShow(jQuery(this));
                },
                hide: function hide(deleteItem) {
                    api.repeaterHide(jQuery(this), deleteItem);
                },
                ready: function ready(setIndexes) {
                    api.$repeaterList.on('sortupdate', setIndexes);
                },
                isFirstItemUndeletable: api.options.isFirstItemUndeletable
            });

            // Delete first item if allowed and empty
            if (!this.options.isFirstItemUndeletable && this.options.empty) {

                this.$repeaterList.find('.fieldhelpers-field-repeater-row').remove();
            }

            if (this.options.collapsable) {

                this.initCollapsable();
            }

            if (this.options.sortable) {

                if (!jQuery.isFunction(jQuery.fn.sortable)) {

                    console.error('Field Helpers Error: Trying to initialize sortable Repeater field but "jquery-ui-sortable" ' + 'is not enqueued.');
                    return;
                } else {

                    this.initSortable();
                }
            }

            // Delay for other plugins
            setTimeout(function () {
                _this2.$field.trigger('repeater-init', [_this2.$field]);
            }, 1);
        }

        /**
         * Initializes the Collapsable feature, if enabled.
         *
         * @since 1.4.0
         */

    }, {
        key: 'initCollapsable',
        value: function initCollapsable() {

            var api = this;

            this.$field.on('click touchend', '[data-repeater-collapsable-handle]', function () {
                console.log('click');
                api.toggleCollapse(jQuery(this).closest('.fieldhelpers-field-repeater-row'));
            });
        }

        /**
         * Initializes the Sortable feature, if enabled.
         *
         * @since 1.4.0
         */

    }, {
        key: 'initSortable',
        value: function initSortable() {

            var api = this;

            this.$repeaterList.sortable({
                axis: 'y',
                handle: '.fieldhelpers-field-repeater-handle',
                forcePlaceholderSize: true,
                placeholder: 'fieldhelpers-sortable-placeholder',
                stop: function stop(e, ui) {

                    api.$repeaterList.trigger('list-update', [api.$repeaterList]);
                }
            });
        }

        /**
         * Toggles a repeater item collapse.
         *
         * @since 1.4.0
         *
         * @param {jQuery} $item
         */

    }, {
        key: 'toggleCollapse',
        value: function toggleCollapse($item) {

            var $content = $item.find('.fieldhelpers-field-repeater-content').first();
            var status = $item.hasClass('opened') ? 'closing' : 'opening';

            if (status === 'opening') {

                $content.stop().slideDown();
                $item.addClass('opened');
                $item.removeClass('closed');
            } else {

                $content.stop().slideUp();
                $item.addClass('closed');
                $item.removeClass('opened');
            }
        }

        /**
         * Shows a new repeater item.
         *
         * @since 1.4.0
         *
         * @param {jQuery} $item Repeater item row.
         */

    }, {
        key: 'repeaterShow',
        value: function repeaterShow($item) {

            this.$field.trigger('repeater-before-add-item', [$item]);

            $item.slideDown();

            if (this.$repeaterList.hasClass('collapsable')) {

                $item.addClass('opened').removeClass('closed');

                // Hide current title for new item and show default title
                $item.find('.fieldhelpers-field-repeater-header span.collapsable-title').html($item.find('.fieldhelpers-field-repeater-header span.collapsable-title').data('collapsable-title-default'));

                $item.find('.collapse-icon').css({ 'transform': 'rotate(-180deg)' });
            }

            // Re-initialize fields in new row
            new _fieldsInit2.default($item);

            this.$field.trigger('repeater-add-item', [$item]);
        }

        /**
         * Removes a repeater item.
         *
         * @since 1.4.0
         *
         * @param {jQuery} $item Repeater item row.
         * @param {function} deleteItem Callback for deleting the item.
         */

    }, {
        key: 'repeaterHide',
        value: function repeaterHide($item, deleteItem) {
            var _this3 = this;

            if (confirm(this.options.l10n['confirm_delete_text'])) {

                this.$field.trigger('repeater-before-delete-item', [$item]);

                $item.slideUp(400, function () {

                    deleteItem();
                    _this3.$field.trigger('repeater-delete-item', [$item]);
                });
            }
        }
    }]);

    return FieldRepeater;
}(_field2.default);

/**
 * Finds and initializes all Repeater fields.
 *
 * @since 1.4.0
 */


var FieldRepeaterInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldRepeaterInitialize($root) {
        _classCallCheck(this, FieldRepeaterInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-repeater]');

        if ($fields.length) {

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldRepeaterInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldRepeater($field)
            });
        }
    }]);

    return FieldRepeaterInitialize;
}();

exports.default = FieldRepeaterInitialize;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Select Field functionality.
 *
 * @since 1.4.0
 */
var FieldSelect = function (_Field) {
    _inherits(FieldSelect, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldSelect($field) {
        _classCallCheck(this, FieldSelect);

        var _this = _possibleConstructorReturn(this, (FieldSelect.__proto__ || Object.getPrototypeOf(FieldSelect)).call(this, $field, 'select'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the select.
     *
     * @since 1.4.0
     */


    _createClass(FieldSelect, [{
        key: 'initField',
        value: function initField() {

            if (!this.options.select2Disabled) {

                if (!jQuery.isFunction(jQuery.fn.rbmfhselect2)) {

                    console.error('Field Helpers Error: Trying to initialize Select field but "select2" ' + 'is not enqueued.');
                    return;
                }

                this.setupSelect2Options();

                this.$field.rbmfhselect2(this.options.select2Options);
            }
        }

        /**
         * Sets up languages.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setupL10n',
        value: function setupL10n() {
            var _this2 = this;

            if (Object.keys(this.options.select2Options.language).length > 0) {

                Object.keys(this.options.select2Options.language).map(function (id) {

                    var text = _this2.options.select2Options.language[id];

                    // All languages must be functions. Turn all into functions.
                    _this2.options.select2Options.language[id] = function (args) {
                        return text;
                    };
                });
            }
        }

        /**
         * Sets up Select2 arguments, allowing for callback arguments.
         *
         * @since 1.4.2
         */

    }, {
        key: 'setupSelect2Options',
        value: function setupSelect2Options() {
            var _this3 = this;

            this.setupL10n();

            // List of available Select2 options that are callbacks
            var callbackOptions = ['escapeMarkup', 'initSelection', 'matcher', 'query', 'sorter', 'templateResult', 'templateSelection', 'tokenizer'];

            Object.keys(this.options.select2Options).map(function (name) {

                if (callbackOptions.indexOf(name) !== -1) {

                    var callbackName = _this3.options.select2Options[name];

                    if (typeof window[callbackName] === 'function') {

                        _this3.options.select2Options[name] = window[callbackName];
                    }
                }
            });

            // Automatically prefix selected items with optgroup label, if using optgroups
            if (this.options.optGroups && this.options.optGroupSelectionPrefix && typeof this.options.select2Options.templateSelection === 'undefined') {

                this.options.select2Options.templateSelection = function (item) {

                    var optGroup = jQuery(item.element).closest('optgroup').attr('label').trim();

                    return optGroup + ': ' + item.text;
                };
            }
        }

        /**
         * Resets the field.
         *
         * @since 1.4.0
         */

    }, {
        key: 'fieldCleanup',
        value: function fieldCleanup() {

            if (this.options.select2Disabled) {

                return;
            }

            var $oldSelect = this.$field.next('.select2');

            if ($oldSelect.length) {

                $oldSelect.remove();
            }

            this.$field.removeClass('select2-hidden-accessible').removeAttr('tablindex aria-hidden');
        }

        /**
         * Sets the field to default. Override in child class if need different method.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setDefault',
        value: function setDefault() {

            this.$field.find('option:selected').prop('selected', false);
            this.$field.trigger('change');
        }
    }]);

    return FieldSelect;
}(_field2.default);

/**
 * Finds and initializes all Select fields.
 *
 * @since 1.4.0
 */


var FieldSelectInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldSelectInitialize($root) {
        _classCallCheck(this, FieldSelectInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-select]');

        if ($fields.length) {

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldSelectInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldSelect($field)
            });
        }
    }]);

    return FieldSelectInitialize;
}();

exports.default = FieldSelectInitialize;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * TextArea Field functionality.
 *
 * @since 1.4.0
 */
var FieldTextArea = function (_Field) {
    _inherits(FieldTextArea, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldTextArea($field) {
        _classCallCheck(this, FieldTextArea);

        var _this = _possibleConstructorReturn(this, (FieldTextArea.__proto__ || Object.getPrototypeOf(FieldTextArea)).call(this, $field, 'textarea'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the WYSIWYG.
     *
     * @since 1.4.0
     */


    _createClass(FieldTextArea, [{
        key: 'initField',
        value: function initField() {

            if (this.options.wysiwyg) {

                if (!wp.editor) {

                    console.error('Field Helpers Error: Trying to initialize a WYSIWYG Text Area field but "wp_editor" ' + 'is not enqueued.');
                    return;
                }

                var settings = jQuery.extend(this.getDefaultEditorSettings(), this.options.wysiwygOptions);

                console.log(settings);
                wp.editor.initialize(this.$field.attr('id'), settings);
            }
        }

        /**
         * Resets the field.
         *
         * @since 1.4.0
         */

    }, {
        key: 'fieldCleanup',
        value: function fieldCleanup() {

            if (this.options.wysiwyg) {

                var id = this.$field.attr('id');

                if (window.tinymce.get(id)) {

                    wp.editor.remove(id);
                } else {

                    this.$field.appendTo(this.$wrapper.find('.fieldhelpers-field-content'));
                    this.$wrapper.find('.wp-editor-wrap').remove();
                }
            }
        }

        /**
         * Fires before deleting the item from a repeater.
         *
         * Removes from wp.editor.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterBeforeDeleteSelf',
        value: function repeaterBeforeDeleteSelf() {

            this.fieldCleanup();
        }

        /**
         * Fires on Repeat delete item.
         *
         * Adds slight delay to field re-initialization.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterOnDeleteItem',
        value: function repeaterOnDeleteItem() {
            var _this2 = this;

            this.fieldCleanup();
            this.repeaterSetID();

            // Add slight delay because all repeater item WYSIWYG's must be unitialized before re-initializing to prevent
            // ID overlap.
            setTimeout(function () {
                _this2.initField();
            }, 1);
        }

        /**
         * Fires on Repeat sort item.
         *
         * Adds slight delay to field re-initialization.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterOnSort',
        value: function repeaterOnSort() {
            var _this3 = this;

            this.fieldCleanup();
            this.repeaterSetID();

            // Add slight delay because all repeater item WYSIWYG's must be unitialized before re-initializing to prevent
            // ID overlap.
            setTimeout(function () {
                _this3.initField();
            }, 1);
        }

        /**
         * Tries to get default editor settings.
         *
         * @since 1.4.0
         *
         * @return {{}}
         */

    }, {
        key: 'getDefaultEditorSettings',
        value: function getDefaultEditorSettings() {

            if (!jQuery.isFunction(wp.editor.getDefaultSettings)) {

                return {};
            } else {

                return wp.editor.getDefaultSettings();
            }
        }
    }]);

    return FieldTextArea;
}(_field2.default);

/**
 * Finds and initializes all TextArea fields.
 *
 * @since 1.4.0
 */


var FieldTextAreaInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldTextAreaInitialize($root) {
        _classCallCheck(this, FieldTextAreaInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-textarea]');

        if ($fields.length) {

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldTextAreaInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldTextArea($field)
            });
        }
    }]);

    return FieldTextAreaInitialize;
}();

exports.default = FieldTextAreaInitialize;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Checkbox Field functionality.
 *
 * @since 1.4.0
 */
var FieldCheckbox = function (_Field) {
    _inherits(FieldCheckbox, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldCheckbox($field) {
        _classCallCheck(this, FieldCheckbox);

        var _this = _possibleConstructorReturn(this, (FieldCheckbox.__proto__ || Object.getPrototypeOf(FieldCheckbox)).call(this, $field, 'checkbox'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the select.
     *
     * @since 1.4.0
     */


    _createClass(FieldCheckbox, [{
        key: 'initField',
        value: function initField() {

            this.$ui = {
                checkboxes: this.$field.find('input[type="checkbox"]')
            };

            this.setupHandlers();

            this.$field.find('input:checked').change();
        }

        /**
         * Sets up class handlers.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setupHandlers',
        value: function setupHandlers() {

            var api = this;

            this.$ui.checkboxes.change(function () {
                api.handleChange(jQuery(this));
            });
        }

        /**
         * Fires on checkbox change.
         *
         * @since 1.4.0
         *
         * @param {jQuery} $input Checkbox input.
         */

    }, {
        key: 'handleChange',
        value: function handleChange($input) {

            if ($input.prop('checked')) {

                this.setActive($input.closest('.fieldhelpers-field-checkbox-row'));
            } else {

                this.setInactive($input.closest('.fieldhelpers-field-checkbox-row'));
            }
        }

        /**
         * Sets the checkbox row as active.
         *
         * @since 1.4.0
         *
         * @param {jQuery} $row
         */

    }, {
        key: 'setActive',
        value: function setActive($row) {

            $row.addClass('fieldhelpers-field-checkbox-row-active');
        }

        /**
         * Sets the checkbox row as inactive.
         *
         * @since 1.4.0
         *
         * @param {jQuery} $row
         */

    }, {
        key: 'setInactive',
        value: function setInactive($row) {

            $row.removeClass('fieldhelpers-field-checkbox-row-active');
        }

        /**
         * Sets the ID to be unique, based off the repeater item index.
         *
         * For checkboxes, there will be multiple IDs in each, and need to be set accordingly.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterSetID',
        value: function repeaterSetID() {

            var ID = this.options.id;
            var $rows = this.$field.find('.fieldhelpers-field-checkbox-row');
            var index = this.$field.closest('[data-repeater-item]').index();

            $rows.each(function () {

                var $field = jQuery(this).find('input[type="checkbox"]');
                var $label = $field.next('label');
                var fieldIndex = jQuery(this).index();
                var newID = ID + '_' + index + '_' + fieldIndex;

                $field.attr('id', newID);
                $label.attr('for', newID);
            });
        }

        /**
         * Sets the field to default.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setDefault',
        value: function setDefault() {

            if (this.options.default) {

                this.$field.find('[value="' + this.options.default + '"]').prop('checked', true).change();
            }
        }
    }]);

    return FieldCheckbox;
}(_field2.default);

/**
 * Finds and initializes all Checkbox fields.
 *
 * @since 1.4.0
 */


var FieldCheckboxInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldCheckboxInitialize($root) {
        _classCallCheck(this, FieldCheckboxInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-checkbox]');

        if ($fields.length) {

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldCheckboxInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldCheckbox($field)
            });
        }
    }]);

    return FieldCheckboxInitialize;
}();

exports.default = FieldCheckboxInitialize;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Radio Field functionality.
 *
 * @since 1.4.0
 */
var FieldRadio = function (_Field) {
    _inherits(FieldRadio, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldRadio($field) {
        _classCallCheck(this, FieldRadio);

        var _this = _possibleConstructorReturn(this, (FieldRadio.__proto__ || Object.getPrototypeOf(FieldRadio)).call(this, $field, 'radio'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the select.
     *
     * @since 1.4.0
     */


    _createClass(FieldRadio, [{
        key: 'initField',
        value: function initField() {

            this.$ui = {
                radios: this.$field.find('input[type="radio"]')
            };

            this.setupHandlers();

            this.$field.find('input:checked').change();
        }

        /**
         * Sets up class handlers.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setupHandlers',
        value: function setupHandlers() {

            var api = this;

            this.$ui.radios.change(function () {
                api.handleChange(jQuery(this));
            });
        }

        /**
         * Fires on radio change.
         *
         * @since 1.4.0
         *
         * @param {jQuery} $input Checkbox input.
         */

    }, {
        key: 'handleChange',
        value: function handleChange($input) {

            this.setInactive(this.$ui.radios.closest('.fieldhelpers-field-radio-row'));
            this.setActive($input.closest('.fieldhelpers-field-radio-row'));
        }

        /**
         * Sets the radio row as active.
         *
         * @since 1.4.0
         *
         * @param {jQuery} $row
         */

    }, {
        key: 'setActive',
        value: function setActive($row) {

            $row.addClass('fieldhelpers-field-radio-row-active');
        }

        /**
         * Sets the radio row as inactive.
         *
         * @since 1.4.0
         *
         * @param {jQuery} $row
         */

    }, {
        key: 'setInactive',
        value: function setInactive($row) {

            $row.removeClass('fieldhelpers-field-radio-row-active');
        }

        /**
         * Sets the ID to be unique, based off the repeater item index.
         *
         * For radios, there will be multiple IDs in each, and need to be set accordingly.
         *
         * @since 1.4.0
         */

    }, {
        key: 'repeaterSetID',
        value: function repeaterSetID() {

            var ID = this.options.id;
            var $rows = this.$field.find('.fieldhelpers-field-radio-row');
            var index = this.$field.closest('[data-repeater-item]').index();

            $rows.each(function () {

                var $field = jQuery(this).find('input[type="radio"]');
                var $label = $field.next('label');
                var fieldIndex = jQuery(this).index();
                var newID = ID + '_' + index + '_' + fieldIndex;

                $field.attr('id', newID);
                $label.attr('for', newID);
            });
        }

        /**
         * Sets the field to default.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setDefault',
        value: function setDefault() {

            if (this.options.default) {

                this.$field.find('[value="' + this.options.default + '"]').prop('checked', true).change();
            }
        }
    }]);

    return FieldRadio;
}(_field2.default);

/**
 * Finds and initializes all Radio fields.
 *
 * @since 1.4.0
 */


var FieldRadioInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldRadioInitialize($root) {
        _classCallCheck(this, FieldRadioInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-radio]');

        if ($fields.length) {

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldRadioInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldRadio($field)
            });
        }
    }]);

    return FieldRadioInitialize;
}();

exports.default = FieldRadioInitialize;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _field = __webpack_require__(0);

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Toggle Field functionality.
 *
 * @since 1.4.0
 */
var FieldToggle = function (_Field) {
    _inherits(FieldToggle, _Field);

    /**
     * Class constructor.
     *
     * @since 1.4.0
     */
    function FieldToggle($field) {
        _classCallCheck(this, FieldToggle);

        var _this = _possibleConstructorReturn(this, (FieldToggle.__proto__ || Object.getPrototypeOf(FieldToggle)).call(this, $field, 'toggle'));

        _this.initField();
        return _this;
    }

    /**
     * Initializes the select.
     *
     * @since 1.4.0
     */


    _createClass(FieldToggle, [{
        key: 'initField',
        value: function initField() {
            var _this2 = this;

            this.getUI();

            // Initial change trigger to help other plugins
            setTimeout(function () {
                _this2.$field.trigger('change', [_this2.$ui.input.val()]);
            }, 1);

            this.setupHandlers();
        }

        /**
         * Retrieves the UI.
         *
         * @since 1.4.0
         */

    }, {
        key: 'getUI',
        value: function getUI() {

            this.$ui = {
                slider: this.$field.find('.fieldhelpers-field-toggle-slider'),
                input: this.$field.find('input[type="hidden"]')
            };
        }

        /**
         * Sets up class handlers.
         *
         * @since 1.4.0
         */

    }, {
        key: 'setupHandlers',
        value: function setupHandlers() {

            var api = this;

            this.$ui.slider.click(function () {
                api.handleClick();
            });
        }

        /**
         * Return if field is checked or not.
         *
         * @since 1.4.0
         *
         * @returns {*}
         */

    }, {
        key: 'isChecked',
        value: function isChecked() {

            return this.$field.hasClass('checked');
        }

        /**
         * Fires on toggle change.
         *
         * @since 1.4.0
         */

    }, {
        key: 'handleClick',
        value: function handleClick() {

            if (this.isChecked()) {

                this.$ui.input.val(this.options.uncheckedValue);
                this.$field.removeClass('checked');
            } else {

                this.$ui.input.val(this.options.checkedValue);
                this.$field.addClass('checked');
            }

            this.$field.trigger('change', [this.$ui.input.val()]);
        }
    }]);

    return FieldToggle;
}(_field2.default);

/**
 * Finds and initializes all Toggle fields.
 *
 * @since 1.4.0
 */


var FieldToggleInitialize = function () {

    /**
     * Class constructor.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $root Root element to initialize fields inside.
     */
    function FieldToggleInitialize($root) {
        _classCallCheck(this, FieldToggleInitialize);

        var api = this;

        this.fields = [];

        var $fields = $root.find('[data-fieldhelpers-field-toggle]');

        if ($fields.length) {

            $fields.each(function () {

                api.initializeField(jQuery(this));
            });
        }
    }

    /**
     * Initializes the field.
     *
     * @since 1.4.0
     *
     * @param {jQuery} $field
     */


    _createClass(FieldToggleInitialize, [{
        key: 'initializeField',
        value: function initializeField($field) {

            this.fields.push({
                $field: $field,
                api: new FieldToggle($field)
            });
        }
    }]);

    return FieldToggleInitialize;
}();

exports.default = FieldToggleInitialize;

/***/ })
/******/ ]);